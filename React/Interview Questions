1. How does React.js work?

âš™ï¸ 1. React builds components

React lets you break your UI into small, reusable pieces called components.
Each component is like a function that returns what the screen should look like.

ğŸ‘‰ Example:

function Welcome() {
return <h1>Hello, world!</h1>;
}

ğŸ§± 2. Components return JSX

JSX looks like HTML but is actually JavaScript.
React uses JSX to describe how the UI should appear.

ğŸ§  3. React creates a Virtual DOM

When you write components, React doesnâ€™t directly change the real web page (the real DOM).
Instead, it first creates a Virtual DOM â€” a lightweight copy of the real DOM.

ğŸ”„ 4. React updates efficiently

When something changes (like data or state):

React compares the new Virtual DOM with the old one (this is called reconciliation).

It finds what has actually changed.

Then it updates only that part of the real DOM â€” not the whole page.

ğŸ‘‰ This makes React fast and efficient.

ğŸ” 5. One-way data flow

Data in React flows from parent to child through props.
This makes it easier to track and debug how data moves.

âœ… In short:

React works by:

Building UI using components

Using JSX to describe how it looks

Maintaining a Virtual DOM

Updating the real DOM efficiently when things change

Thatâ€™s how React makes web apps fast, modular, and easy to manage ğŸš€

---

2. What is state in React and how do you update it?

State is like a componentâ€™s memory â€” it holds data that can change over time.

When the state changes, React automatically re-renders the component to show the new data on the screen.

ğŸ§  Example:
import React, { useState } from "react";

function Counter() {
const [count, setCount] = useState(0); // state variable

return (

<div>
<h1>Count: {count}</h1>
<button onClick={() => setCount(count + 1)}>Increase</button>
</div>
);
}

ğŸ§© Whatâ€™s happening here:

count â†’ is the state variable (current value).

setCount â†’ is the function to update that value.

useState(0) â†’ sets the initial state to 0.

When you click the button:

setCount(count + 1) updates the state.

React sees the change â†’ re-renders the component â†’ and shows the new count.

---

3. What are props and default props in React?

ğŸ§© Props in React

Props (short for properties) are like function arguments â€” they let you pass data from one component to another (usually from a parent to a child).

Think of them as the inputs to a component.

ğŸ‘‰ Example:

function Welcome(props) {
return <h1>Hello, {props.name}!</h1>;
}

// Passing props
<Welcome name="Prem" />

Here:

name is a prop.

The Welcome component gets props.name = "Prem" and displays:
ğŸ‘‰ Hello, Prem!

âš™ï¸ Default Props

Default props are fallback values that a component uses if no prop is passed.

ğŸ‘‰ Example:

function Welcome(props) {
return <h1>Hello, {props.name}!</h1>;
}

Welcome.defaultProps = {
name: "Guest"
};

// Usage
<Welcome /> // Output: Hello, Guest!
<Welcome name="Prem" /> // Output: Hello, Prem!

So,

If you donâ€™t pass a prop â†’ it uses the default value.

If you do pass one â†’ it uses your value instead.

---

3. What is JSX and how is it converted into JavaScript?

ğŸ’¡ What is JSX?

JSX stands for JavaScript XML.
It lets you write HTML-like code inside JavaScript when building React components.

ğŸ‘‰ Example:

const element = <h1>Hello, Prem!</h1>;

Even though it looks like HTML, itâ€™s not HTML â€” itâ€™s a special syntax that React understands.

JSX makes your code easier to write and read because it lets you describe what your UI should look like directly in your JavaScript code.

âš™ï¸ How JSX is converted into JavaScript

Browsers cannot understand JSX directly, so it must be converted (transpiled) into regular JavaScript before running in the browser.

This conversion is done by Babel (a popular JavaScript compiler).

ğŸ§  Example of conversion

JSX:

const element = <h1>Hello, Prem!</h1>;

After Babel converts it:

const element = React.createElement("h1", null, "Hello, Prem!");

âš¡ What happens next

React.createElement() creates a virtual DOM object (not a real HTML element).

React uses this virtual DOM to figure out what to render on the real web page efficiently.

âœ… In short:

JSX â†’ A syntax to write HTML-like code in JavaScript.

Babel â†’ Converts JSX into React.createElement() JavaScript code.

React â†’ Uses that to build and update the virtual DOM, which updates the real DOM efficiently.

---

4. ğŸ’¡ What are Fragments in React?

Fragments are like invisible containers in React.
They let you group multiple elements together without adding extra HTML tags to the DOM.

ğŸ§  Why we need Fragments

In React, a component must return only one parent element.
If you try to return multiple elements side by side, youâ€™ll get an error.

âŒ Example (invalid):

function App() {
return (

<h1>Hello</h1>
<p>Welcome to React!</p>
);
}

âœ… With Fragment:

function App() {
return (
<React.Fragment>

<h1>Hello</h1>
<p>Welcome to React!</p>
</React.Fragment>
);
}

âœ¨ Shortcut syntax

You can use a short form for fragments:

function App() {
return (
<>

<h1>Hello</h1>
<p>Welcome to React!</p>
</>
);
}

This does the same thing but is cleaner and more common.

âš™ï¸ What happens in the DOM

Fragments donâ€™t create an extra <div> or wrapper tag â€”
React just renders the child elements directly, keeping the DOM clean.

---

5. What is the difference between controlled and uncontrolled components?

âš™ï¸ 1. Controlled Components

A controlled component is a form element (like <input>, <textarea>, etc.) whose value is controlled by React state.

That means:

The form data is stored in React state, not in the DOM.

You use useState() (or this.state in class components) to manage the inputâ€™s value.

Every time the user types something, React updates the state â†’ re-renders the input.

ğŸ‘‰ Example:

import React, { useState } from "react";

function ControlledInput() {
const [name, setName] = useState("");

return (

<div>
<input
type="text"
value={name} // value comes from state
onChange={(e) => setName(e.target.value)} // updates state
/>
<p>Hello, {name}</p>
</div>
);
}

âœ… Key idea: React controls the input value using its state.

âš™ï¸ 2. Uncontrolled Components

An uncontrolled component is where the form data is handled by the DOM itself, not React state.

You use a ref to directly access the DOM value when needed.

ğŸ‘‰ Example:

import React, { useRef } from "react";

function UncontrolledInput() {
const inputRef = useRef();

const handleSubmit = () => {
alert(`Hello, ${inputRef.current.value}`);
};

return (

<div>
<input type="text" ref={inputRef} /> {/_ value stored in DOM _/}
<button onClick={handleSubmit}>Submit</button>
</div>
);
}

âœ… Key idea: The input manages its own value â€” React just reads it when needed.

---

6. 12. How does the useState hook work?

The useState hook allows you to add state to functional components. It returns a state variable and a setter function to update that state. When the state changes, React re-renders the component with the updated value.

Example:

import { useState } from 'react';

function Counter() {
const [count, setCount] = useState(0);

return (

<div>
<p>Count: {count}</p>
<button onClick={() => setCount(count + 1)}>Increment</button>
</div>
);
}
In this example:

count is the current state value.
setCount is the function used to update state.
0 is the initial value when the component mounts. When setCount is called, React re-renders Counter with the new count value.

---

7. What is useEffect in React and what is the role of its dependency array?

ğŸ’¡ What is useEffect in React?

useEffect is a Hook that lets you perform side effects in your React components.

ğŸ§  Side effects mean anything that affects something outside the component, such as:

Fetching data from an API

Manipulating the DOM directly

Setting up timers or intervals

Subscribing/unsubscribing to events

âš™ï¸ Syntax:
useEffect(() => {
// Side effect logic here
});

ğŸ§© Example 1: Basic useEffect
import React, { useState, useEffect } from "react";

function Example() {
const [count, setCount] = useState(0);

useEffect(() => {
console.log("Component rendered or updated!");
});

return (

<div>
<p>Count: {count}</p>
<button onClick={() => setCount(count + 1)}>Increase</button>
</div>
);
}

ğŸ‘‰ Every time the component renders (even after updates), the code inside useEffect runs.
So here, the message logs every time count changes.

ğŸ¯ Role of the Dependency Array

useEffect can take a second argument â€” an array of dependencies.

useEffect(() => {
// Side effect logic
}, [dependencies]);

The dependency array tells React when to run the effect.

ğŸ” 3 main ways the dependency array affects behavior:
Case Code Example When it runs

1. No dependency array useEffect(() => {...}); Runs after every render (initial + updates)
2. Empty dependency array useEffect(() => {...}, []); Runs only once (when the component mounts)
3. With dependencies useEffect(() => {...}, [count]); Runs only when count changes
   ğŸ§  Example 2: useEffect with dependency
   useEffect(() => {
   console.log("Count changed!");
   }, [count]);

âœ… This will run only when count changes, not on every render.

ğŸ§¹ Cleanup function (optional)

If your effect sets up something like a timer or subscription, you should clean it up to avoid memory leaks.

useEffect(() => {
const timer = setInterval(() => console.log("Running..."), 1000);

return () => {
clearInterval(timer); // Cleanup when component unmounts or re-runs
};
}, []);

---

8. What is the useContext hook and when should you use it?

useContext is a Hook that lets you access data from a React Context directly in a component â€” without having to pass props manually at every level.

It helps you share data easily between components without "prop drilling".

ğŸ§© What is Prop Drilling?

Prop drilling means passing data from a parent â†’ to child â†’ to grandchild, even when only the deepest child needs it.

Example (without context):

function App() {
const username = "Prem";
return <Parent username={username} />;
}

function Parent({ username }) {
return <Child username={username} />;
}

function Child({ username }) {
return <h1>Hello, {username}</h1>;
}

Here, the username prop has to be passed through every layer, even if only Child needs it â€” this becomes messy in large apps.

âš™ï¸ React Context + useContext = Easy Sharing

With Context, you can store shared data in one place,
and with useContext, you can easily access it from any component â€” no prop drilling needed.

ğŸ§  Example: Using useContext
import React, { createContext, useContext } from "react";

// 1ï¸âƒ£ Create the context
const UserContext = createContext();

// 2ï¸âƒ£ Provide the context value
function App() {
return (
<UserContext.Provider value="Prem">
<Child />
</UserContext.Provider>
);
}

// 3ï¸âƒ£ Consume the context value
function Child() {
const username = useContext(UserContext); // access context directly
return <h1>Hello, {username}!</h1>;
}

âœ… Output:

Hello, Prem!

ğŸ§© When to use useContext

Use it when:

You need to share data across multiple components, especially at different levels of the component tree.

Example use cases:

Current user info (login data)

Theme (light/dark mode)

Language or localization settings

Global app settings or preferences

âš ï¸ When not to use it

Avoid overusing context for data that changes very frequently (like input values or counters),
because it can cause unnecessary re-renders in all components using that context.

âœ… In short:
Concept Description
useContext React Hook that lets you read data from a context directly.
Purpose Avoids prop drilling â€” passes data without going through every component.
Used with createContext() and <Context.Provider>
When to use For global data like user, theme, or language.

ğŸ‘‰ Simple summary:
useContext = â€œA shortcut to access shared data (context) anywhere in your component tree â€” without passing props manually.â€

---

9. What is useReducer in React?

useReducer is a React Hook used to manage complex state logic â€” especially when your state updates depend on multiple conditions or previous state values.

It works like a mini Redux built into React.

ğŸ”¹ Syntax
const [state, dispatch] = useReducer(reducer, initialState);

reducer â†’ a function that decides how to update the state

initialState â†’ starting state value

dispatch â†’ a function to trigger (dispatch) an action that changes the state

ğŸ§  How it works (step-by-step)

You define a reducer function â€” it takes the current state and an action, and returns the new state.

You call useReducer and get back state and dispatch.

When something happens (like a button click), you call dispatch({ type: "something" }).

React runs the reducer function and updates the state accordingly.

âœ… Example 1: Counter using useReducer
import React, { useReducer } from "react";

// 1ï¸âƒ£ Define reducer function
function reducer(state, action) {
switch (action.type) {
case "increment":
return { count: state.count + 1 };
case "decrement":
return { count: state.count - 1 };
default:
return state;
}
}

// 2ï¸âƒ£ Use it in component
function Counter() {
const [state, dispatch] = useReducer(reducer, { count: 0 });

return (

<div>
<h2>Count: {state.count}</h2>
<button onClick={() => dispatch({ type: "increment" })}>+</button>
<button onClick={() => dispatch({ type: "decrement" })}>-</button>
</div>
);
}

export default Counter;

ğŸ§© How it works:

state.count holds the current value.
When you click +, it dispatches {type: "increment"}.
The reducer returns {count: previousCount + 1}.

---

10. ğŸ§© What is useRef in React?

useRef is a React Hook that lets you:

Access DOM elements directly, and

Store mutable values that persist between renders without causing re-renders.

ğŸ‘‰ In simple words:

Itâ€™s like a container (or box) that holds a value in its .current property.
That value stays the same even if the component re-renders.

ğŸ§  Syntax
const myRef = useRef(initialValue);

myRef is an object like { current: initialValue }.

You can change it anytime:

myRef.current = newValue;

Changing .current does not trigger a re-render.

âœ… Example 1: Accessing a DOM element
import React, { useRef } from "react";

function InputFocus() {
const inputRef = useRef();

const handleFocus = () => {
inputRef.current.focus(); // âœ… Focuses the input element
};

return (

<div>
<input ref={inputRef} type="text" placeholder="Type here..." />
<button onClick={handleFocus}>Focus Input</button>
</div>
);
}

export default InputFocus;

ğŸ§© Explanation:

useRef() gives you a reference object.

You attach it to <input> using ref={inputRef}.

Now inputRef.current points to the actual DOM node.

You can call DOM methods like .focus().

âœ… Example 2: Storing a mutable value
import React, { useRef, useState } from "react";

function RenderCounter() {
const [count, setCount] = useState(0);
const renderCount = useRef(0);

renderCount.current = renderCount.current + 1;

return (

<div>
<p>Count: {count}</p>
<p>Component rendered: {renderCount.current} times</p>
<button onClick={() => setCount(count + 1)}>Increase</button>
</div>
);
}

ğŸ§  Here, renderCount.current stores how many times the component has rendered â€”
and it does not cause re-renders when updated.

---

11. ğŸ§© What is useMemo in React?

useMemo is a React Hook that helps you optimize performance by remembering (caching) the result of an expensive calculation â€” so React doesnâ€™t have to redo it every time the component re-renders.

ğŸ‘‰ In simple terms:

useMemo â€œremembersâ€ the output of a function until its dependencies change.

ğŸ§  Syntax
const memoizedValue = useMemo(() => {
// some expensive calculation
return result;
}, [dependencies]);

The function inside useMemo runs only when something in the dependency array changes.

Otherwise, React uses the cached value from the previous render.

import React, { useState, useMemo } from "react";

function WithUseMemo() {
const [count, setCount] = useState(0);
const [text, setText] = useState("");

const expensiveCalculation = (num) => {
console.log("Calculating...");
let total = 0;
for (let i = 0; i < 1000000000; i++) {
total += i;
}
return total + num;
};

// âœ… useMemo caches the result until `count` changes
const total = useMemo(() => expensiveCalculation(count), [count]);

return (

<div>
<p>Expensive Result: {total}</p>
<button onClick={() => setCount(count + 1)}>Increment ({count})</button>
<input value={text} onChange={(e) => setText(e.target.value)} />
</div>
);
}

export default WithUseMemo;
ğŸ§  Now:

The expensive function runs only when count changes.
Typing in the input (text) wonâ€™t trigger it again.

âœ… Result: Better performance ğŸš€

---

12. ğŸ§© What is useCallback in React?

useCallback is a React Hook that lets you save (or memoize) a function, so that the same function instance is reused between re-renders â€” unless its dependencies change.

ğŸ’¬ In simple words:

useCallback remembers a function so that it doesnâ€™t get recreated every time your component re-renders.

import React, { useState, useCallback } from "react";

function Counter({ onClick }) {
console.log("Child re-rendered");
return <button onClick={onClick}>Increment</button>;
}

function App() {
const [count, setCount] = useState(0);
const [text, setText] = useState("");

// âœ… useCallback memoizes the function
const handleClick = useCallback(() => {
setCount((prev) => prev + 1);
}, []);

return (

<div>
<h2>Count: {count}</h2>
<Counter onClick={handleClick} />
<input value={text} onChange={(e) => setText(e.target.value)} />
</div>
);
}

export default App;
ğŸ§  Now:

handleClick function is the same across re-renders.

Typing in the input wonâ€™t cause the Counter to re-render.

âœ… Better performance!

---

13. ğŸ§© What are Custom Hooks in React?

A Custom Hook is your own hook â€” a reusable function that uses one or more built-in React hooks (useState, useEffect, etc.) to share logic between components.

ğŸ’¬ In simple words:

A custom hook lets you extract reusable logic from a component into a separate function so you can use it again and again.

ğŸ§  Why do we need them?

Sometimes, you have the same logic repeated in multiple components â€” for example:

fetching data from an API

managing form input

handling timers, scrolls, etc.

Instead of copying the same code everywhere, you can put that logic inside a custom hook.

ğŸ§± How to create a custom hook

A custom hook is just a normal JavaScript function.

Its name must start with â€œuseâ€ (like useFetch, useCounter, useForm).

Inside it, you can use other hooks like useState, useEffect, etc.

âœ… Example 1: Creating a Custom Hook (useCounter)
import { useState } from "react";

// ğŸ‘‡ Custom Hook
function useCounter(initialValue = 0) {
const [count, setCount] = useState(initialValue);

const increment = () => setCount((c) => c + 1);
const decrement = () => setCount((c) => c - 1);
const reset = () => setCount(initialValue);

return { count, increment, decrement, reset };
}

export default useCounter;

ğŸ§© Using it in a component:
import React from "react";
import useCounter from "./useCounter";

function CounterComponent() {
const { count, increment, decrement, reset } = useCounter(5);

return (

<div>
<h2>Count: {count}</h2>
<button onClick={increment}>+</button>
<button onClick={decrement}>-</button>
<button onClick={reset}>Reset</button>
</div>
);
}

export default CounterComponent;

âœ… Now:

You can use useCounter() in any component.

Logic is clean, reusable, and easy to maintain.

âœ… Example 2: Custom Hook for Fetching Data (useFetch)
import { useState, useEffect } from "react";

function useFetch(url) {
const [data, setData] = useState(null);
const [loading, setLoading] = useState(true);

useEffect(() => {
fetch(url)
.then((res) => res.json())
.then((data) => {
setData(data);
setLoading(false);
});
}, [url]);

return { data, loading };
}

export default useFetch;

Using it:
import React from "react";
import useFetch from "./useFetch";

function App() {
const { data, loading } = useFetch("https://jsonplaceholder.typicode.com/users");

if (loading) return <p>Loading...</p>;

return (

<ul>
{data.map((user) => (
<li key={user.id}>{user.name}</li>
))}
</ul>
);
}

export default App;

---

14. ğŸ§© What are the Rules of Hooks in React?

React has two main rules for using Hooks.
These rules make sure that React knows when and how to run hooks correctly.

âœ… Rule 1: Only call hooks at the top level

Donâ€™t call hooks inside loops, conditions, or nested functions.
Always call them at the top of your component or custom hook.

âœ… Rule 2: Only call hooks from React functions

Call hooks only from:

React functional components, or

Custom hooks (your own hooks starting with use).

---

15. What is State Management in React?

State management means controlling how data (state) is stored, updated, and shared between components in a React app.

Think of state as the appâ€™s â€œmemoryâ€ â€”

âš™ï¸ Why do we need State Management?

Because in React, components often need to share or update data.
Managing this flow of data in a clean and predictable way = state management.

âœ… 1. Local State
ğŸ’¬ Simple definition:

Local state is data managed inside one component only.

ğŸŒ 2. Global State
ğŸ’¬ Simple definition:

Global state is data that needs to be shared between multiple components.

Example:
If you have a shopping cart, and both the Cart and Navbar need to show the total items â€”
you canâ€™t keep that data local. It should be global.

---

16. ğŸ§© What are State Management Solutions in React/Next.js?

State management solutions are tools or libraries that help you store, update, and share state (data) across your React or Next.js app â€” especially when it becomes too complex for just useState or useContext.

âœ… 1. Reactâ€™s Built-in Options
ğŸ”¹ useState

For simple, local state (inside one component).

Example: form inputs, counters.

ğŸ”¹ useReducer

Good for complex state logic in a single component (like a mini Redux).

Example: when state updates depend on previous state or multiple actions.

ğŸ”¹ Context API

For global state (shared between components).

Great for small to medium apps.

Common use: Theme, Auth, Language, Cart.

ğŸ§± 2. Popular External Libraries
âš¡ Redux / Redux Toolkit

Most popular global state manager.

Good for large apps with lots of shared data.

Uses a central store and actions/reducers.

ğŸª¶ Zustand

Lightweight and simple alternative to Redux.

Uses a store and feels like Reactâ€™s useState.

---

17. When should you use Redux over Context API?

ğŸ§  Context API vs Redux â€” Basic Idea
ğŸ”¹ Context API

Built into React (no extra library)

Good for small to medium apps

Used for simple global data like theme, language, or user login

ğŸ”¹ Redux

External library for predictable state management

Best for large or complex apps

Manages shared state, async logic, and debugging much better

ğŸ§  In short (Interview answer):

You should use Context API for small apps or simple global data like theme or auth.
But use Redux when your app has complex shared state, frequent updates, or needs debugging and middleware support.

---

18. What is the difference between Client State and Server State?

ğŸ§  1. Client State (Frontend State)

â¡ï¸ Stored and managed inside the browser (React app itself).
It doesnâ€™t come from a server â€” itâ€™s created and changed by the user or app logic.

ğŸŒ 2. Server State (Backend Data)

â¡ï¸ Data that lives on a server, and your app fetches it using APIs (like fetch() or axios).
You donâ€™t directly control this data â€” it depends on the backend.

ğŸ”¹ Examples:
User data from /api/user
Product list from database
Posts or comments fetched from a server
Data that can change outside your app (e.g., another user updates it)

ğŸ§© In short (Interview answer):

Client state is data managed inside your React app (like form inputs or UI state).
Server state is data fetched from a backend (like users or posts), which may change outside your app and needs to be synchronized through APIs.

basic example:
ğŸ§© Whatâ€™s happening:

Server State: Component fetches user data from the API using useEffect.

Client State: User types in the search box.
React filters the users list (fetched from server) using the client state (search).
So both states work together:
The server provides data.
The client controls how that data is displayed or filtered.

---

19. ğŸ§  What is the Context API in React?

â¡ï¸ The Context API is a feature in React that lets you share data between components â€” without having to pass props manually at every level.

It helps you avoid "prop drilling" â€” thatâ€™s when you pass props from parent â†’ child â†’ grandchild â†’ great-grandchild, just to get data to a deep component.

ğŸŒ Using Context API (Cleaner Way)
import React, { createContext, useContext } from "react";

// 1ï¸âƒ£ Create Context
const UserContext = createContext();

function App() {
return (
// 2ï¸âƒ£ Provide the data
<UserContext.Provider value="Prem">
<Parent />
</UserContext.Provider>
);
}

function Parent() {
return <Child />;
}

function Child() {
return <GrandChild />;
}

function GrandChild() {
// 3ï¸âƒ£ Consume the data
const user = useContext(UserContext);
return <h1>Hello, {user}</h1>;
}

export default App;

ğŸ§  How it works:

createContext() â†’ creates a Context object.

Provider â†’ makes the data available to all child components.

useContext() â†’ allows any child to access that data directly, without prop drilling.

ğŸ¯ When to Use Context API

âœ… Use it when you want to share data that many components need, like:

User authentication info (logged in user)
Theme (dark/light mode)
App language
Global settings

ğŸ§¾ In short (Interview Answer)

The Context API in React allows data to be shared globally across components without passing props manually through every level.
It solves the problem of prop drilling by using a Provider to supply data and the useContext hook to consume it in child components.

---

20. ğŸ§  What is Persistent State?

Persistent state means data that stays saved even after the page is refreshed or the user closes and reopens the app.

Normally, Reactâ€™s state (useState, useReducer) is temporary â€” itâ€™s lost when you refresh the page.

So we need to store it somewhere permanent, like:

Browser storage (LocalStorage, SessionStorage)

IndexedDB (for large data)

Backend/database (for user-specific data)

Cookies (for small authentication data)

ğŸ’¾ 1. Using Local Storage (most common way)

LocalStorage saves keyâ€“value pairs in the browser and doesnâ€™t expire.

import React, { useState, useEffect } from "react";

function PersistentCounter() {
// ğŸ§  Load initial value from localStorage (if any)
const [count, setCount] = useState(() => {
const saved = localStorage.getItem("count");
return saved ? JSON.parse(saved) : 0;
});

// ğŸ’¾ Save to localStorage whenever count changes
useEffect(() => {
localStorage.setItem("count", JSON.stringify(count));
}, [count]);

return (

<div>
<h2>Count: {count}</h2>
<button onClick={() => setCount(count + 1)}>Increment</button>
<button onClick={() => setCount(0)}>Reset</button>
</div>
);
}

export default PersistentCounter;

âœ… Now if you refresh the page, the count will stay the same.

ğŸ§­ 2. Using Session Storage

Similar to LocalStorage, but data is cleared when you close the browser tab.

sessionStorage.setItem("key", "value");
sessionStorage.getItem("key");

ğŸŸ¢ Good for temporary session data (like form progress).

ğŸ§  In short (Interview answer):

Persistent state means saving data so it remains after a page reload.
You can handle it in React using localStorage, sessionStorage, or by saving to a backend database.
Tools like Redux Persist or Zustand persist make this easier in larger apps.

---

21. What is the difference between derived state and computed state in React?

ğŸ§  1. Derived State (from Props or Other State)

â¡ï¸ Derived state means a piece of state that is based on (or copied from) another state or prop.

Youâ€™re storing it separately in the component â€” even though you could calculate it from existing data.

ğŸ§© Example of Derived State
function Cart({ items }) {
// âŒ Derived state â€” total can be calculated from items
const [total, setTotal] = useState(0);

useEffect(() => {
const newTotal = items.reduce((sum, item) => sum + item.price, 0);
setTotal(newTotal);
}, [items]);

return <p>Total: â‚¹{total}</p>;
}

Here, total is derived from items.
Weâ€™re storing it in state unnecessarily â€” which can cause bugs or out-of-sync issues if we forget to update it.

âœ… Better way: Compute it directly instead of storing it:

const total = items.reduce((sum, item) => sum + item.price, 0);

âš™ï¸ 2. Computed State

â¡ï¸ Computed state is not stored in useState.
Instead, itâ€™s calculated on the fly (derived at render time) based on other state or props.

ğŸ§© Example of Computed State
function Cart({ items }) {
// ğŸ§  items is the only real state/prop
const total = items.reduce((sum, item) => sum + item.price, 0); // computed

return <p>Total: â‚¹{total}</p>;
}

Here:
total is computed, not stored.
It always stays in sync with items.
No extra state or side effect is needed.

---

22. How can you optimize state updates for performance in React?

Every time you update state in React, React re-renders that component â€” and all its child components (unless optimized).
Too many unnecessary re-renders can slow down your app, especially in large applications.

So we need to optimize how and when state updates happen.
âš¡ 1. Keep state minimal and local

Only store what you actually need in state.
If a value can be calculated from another state or prop, donâ€™t store it separately.

âš™ï¸ 2. Use functional updates for dependent state

If your new state depends on the previous state, use the functional form of setState â€” itâ€™s faster and safer.

ğŸ§© Example:

setCount(prev => prev + 1);

Instead of:

setCount(count + 1);

This avoids potential stale state issues during batching.

ğŸ§© 3. Batch multiple state updates

React automatically batches state updates inside event handlers â€” but if youâ€™re updating state in async code (like setTimeout, promises), you can use Reactâ€™s automatic batching (React 18+).

ğŸ§© Example:

setCount(c => c + 1);
setName("Prem");
// React 18 batches these â€” one re-render only âœ…

ğŸ’¡ 4. Use useMemo for expensive calculations

If youâ€™re performing heavy computations based on state, memoize the result so React doesnâ€™t re-calculate unnecessarily.

âš™ï¸ 5. Use useCallback for stable functions

Passing inline functions as props can trigger re-renders of child components unnecessarily.
Use useCallback to memoize them.

âš™ï¸ 7. Lift state up only when necessary

Donâ€™t keep all state in parent components â€” it causes many unnecessary re-renders in children.
Keep state as close to where itâ€™s used as possible.

ğŸš€ 8. Use libraries for complex state

For large apps, managing all state in React components can cause frequent updates.
Use libraries like:

Zustand
Redux Toolkit
Recoil

---

23. ğŸ§© What does â€œasynchronous state updatesâ€ mean?

When you call setState (or setCount, etc. using useState),
React doesnâ€™t immediately update the state.

Instead, it schedules an update and re-renders later.
This makes state updates asynchronous â€” meaning, you canâ€™t rely on the state value right after calling setState.

âœ… How to handle this correctly

1. Use Functional Updates

If your new state depends on the previous state,
always use the functional form of setState.

setCount(prev => prev + 1);

2. Use useEffect to Respond After State Updates

If you need to perform something after state changes (like logging or making an API call),
use the useEffect hook.

useEffect(() => {
console.log("Count changed:", count);
}, [count]);

This runs after React finishes updating the DOM.

4. Batching in React 18

In React 18+, multiple state updates inside the same event handler are batched automatically, meaning React does one re-render at the end.

const handleClick = () => {
setCount(c => c + 1);
setName("Prem");
// âœ… React batches these â€” only one render
};

But if updates happen in an async callback (like setTimeout), React still batches them automatically in React 18.

ğŸš€ In short (Interview Answer):

React state updates are asynchronous â€” React batches them for performance.
To handle this, use functional updates (setCount(prev => prev + 1)) when depending on the previous value, and use useEffect when you need to react to a state change after itâ€™s applied.

---

24. ğŸ‘‡

ğŸ§  What is the Virtual DOM?

The Virtual DOM (VDOM) is a lightweight copy of the real DOM (Document Object Model).
Itâ€™s just a JavaScript object that represents what the real DOM should look like.

ğŸ— How React Uses the Virtual DOM

Hereâ€™s the step-by-step process ğŸ‘‡

1ï¸âƒ£ Initial Render

When your React app starts, React creates a Virtual DOM tree from your JSX.
Then, it renders that structure to the real DOM (in the browser).

2ï¸âƒ£ When State or Props Change
React creates a new Virtual DOM tree that reflects the new UI.
It then compares the new Virtual DOM with the previous Virtual DOM â€” this process is called â€œdiffingâ€.

3ï¸âƒ£ Efficient Update (Reconciliation)

React figures out which parts actually changed.
It updates only those parts in the real DOM â€” instead of re-rendering the entire page.
This is called reconciliation, and it makes React super fast âš¡

ğŸ“Š Example

Letâ€™s say your component looks like this:

function App() {
const [count, setCount] = useState(0);

return (

<div>
<h1>Hello Prem</h1>
<p>Count: {count}</p>
<button onClick={() => setCount(count + 1)}>Increment</button>
</div>
);
}

When count changes:
React builds a new Virtual DOM with the updated count.
It compares it to the old Virtual DOM.
It sees that only the <p> tag changed.
React updates just that part in the real DOM â€” not the entire page.

ğŸ§© In short (Interview Answer):

The Virtual DOM is a lightweight copy of the real DOM that React uses to track UI changes efficiently.
When state or props change, React updates the Virtual DOM first, compares it with the previous version (diffing), and then updates only the parts of the real DOM that actually changed â€” improving performance.

---

25. ğŸ§  What is React.memo?

React.memo is a higher-order component (HOC) that helps prevent unnecessary re-renders of a component.

In short:

ğŸª„ React.memo makes React remember (memoize) the output of a component â€” and re-render it only if its props change.

ğŸ§© Why is this useful?

In React, when a parent component re-renders, all of its child components also re-render â€” even if their props didnâ€™t change.

This can cause performance issues if the child components are heavy (like large lists, charts, etc.).

React.memo helps by skipping re-renders for components whose props stay the same.

âš™ï¸ Example

Without React.memo ğŸ‘‡

function Child({ name }) {
console.log("Child rendered");
return <h2>Hello {name}</h2>;
}

function Parent() {
const [count, setCount] = useState(0);
return (
<>
<button onClick={() => setCount(count + 1)}>Increment {count}</button>
<Child name="Prem" />
</>
);
}

â¡ï¸ Even though the name prop never changes,
the Child component will re-render every time Parent re-renders.

âœ… With React.memo
const Child = React.memo(function Child({ name }) {
console.log("Child rendered");
return <h2>Hello {name}</h2>;
});

Now, when you click the button:

Parent re-renders âœ…

But Child does not re-render ğŸš« (because its props didnâ€™t change)

âš¡ Why this improves performance

Fewer unnecessary renders
Faster UI updates
Better performance for large apps or heavy components

ğŸš€ In short (Interview Answer):

React.memo is used to prevent unnecessary re-renders of functional components.
It remembers (memoizes) the componentâ€™s output and only re-renders it if its props have changed, helping improve performance.

---

26. âš¡ If a React app is slow, here are the key techniques to optimize it:

ğŸ§© 1. Prevent Unnecessary Re-renders

React re-renders components when props or state change â€” even if the output is the same.

âœ… Solutions:

Use React.memo for functional components

Use useCallback for memoizing functions

Use useMemo for expensive calculations

Example:

const Child = React.memo(({ data }) => <div>{data}</div>);

ğŸ§  2. Optimize State Management

Keep state as local as possible â€” donâ€™t store everything in a top-level parent or context.

âœ… Tips:

Lift state up only when necessary

Avoid re-rendering the whole tree for small updates

Use libraries like Zustand, Jotai, or Redux Toolkit efficiently

ğŸ–¼ï¸ 3. Code Splitting and Lazy Loading

Donâ€™t load everything at once â€” split your code into smaller bundles.

âœ… Use:

const Profile = React.lazy(() => import('./Profile'));
<Suspense fallback={<p>Loading...</p>}>
<Profile />
</Suspense>

This loads Profile only when needed, improving initial load time.

âš™ï¸ 4. Memoize Expensive Computations

If a function or calculation is heavy, memoize it using useMemo.

âœ… Example:

const sortedData = useMemo(() => heavySortFunction(data), [data]);

This avoids recalculating unless data actually changes.

5. ğŸ§© The Problem â€” Large Lists Slow Down React

Imagine you have a list of 10,000 items (like user names or messages).

If you write this:

{items.map(item => <div>{item.name}</div>)}

React will try to render all 10,000 items in the DOM at once ğŸ˜«

That means:

The browser creates 10,000 <div> elements.

The DOM becomes huge.

Scrolling and rendering become very slow.

ğŸ§  The Idea Behind Virtualization (Windowing)

Instead of rendering everything at once,
React can only render whatâ€™s visible on the screen â€” like a â€œwindowâ€ into your list.

Think of it like Instagram or Facebook feeds:
Even though you can scroll infinitely, the app doesnâ€™t load every post from the start â€” it only shows what you see on screen and a few nearby posts.

ğŸª„ Thatâ€™s called â€œWindowingâ€ or â€œVirtualizationâ€
ğŸ‘‰ What happens:

Only a small portion of the list (say 20â€“30 items) is rendered.

When you scroll, React removes old items and adds new ones that come into view.

The user feels like the full list is there â€” but only a few items actually exist in the DOM at any moment.

ğŸ“· 6. Optimize Images and Assets

Use compressed images

Use lazy loading for images (<img loading="lazy" />)

Use CDN for static assets

âš¡ 7. Avoid Inline Functions and Objects

Inline functions and objects create new references on every render, causing child components to re-render.

âœ… Use:

const handleClick = useCallback(() => { ... }, []);

ğŸ“‰ 8. Use React DevTools and Profiler

Use the React Profiler (in browser DevTools) to:

Identify slow components

Check which components re-render unnecessarily

ğŸ•’ 9. Debounce or Throttle User Input

Avoid updating state on every keystroke.

âœ… Example:

const debouncedSearch = useCallback(debounce(handleSearch, 500), []);

ğŸš€ 10. Production Build Optimization

Run npm run build for production â€” it minifies code and removes dev checks.

Use caching and gzip compression on your server.

ğŸ§¾ In short (Interview Summary Answer):

To optimize a slow React app, I would first identify bottlenecks using the React Profiler. Then Iâ€™d reduce unnecessary re-renders with React.memo, useCallback, and useMemo. Iâ€™d also implement code-splitting, list virtualization, and lazy loading for performance. Additionally, Iâ€™d optimize assets, limit state scope, and ensure the app runs in a production build.

---

27. ğŸ§© What is Code Splitting?

Normally, when you build a React app, all your code is bundled together into one big JavaScript file (bundle.js).

âœ… That means:
When a user opens your app, the browser downloads the entire bundle â€” even the code for pages or features they might never visit.

âŒ This makes your app slow to load initially.

âš™ï¸ Code Splitting fixes this.

It means splitting your code into smaller chunks (files) that load only when needed.

So instead of one big bundle, you get:

main.js (for homepage)
about.js (for About page)
profile.js (for Profile page)

When the user goes to /profile, React loads only profile.js â€” on demand.
This reduces the initial loading time and improves performance. ğŸš€

---

28. ğŸ§  What is Lazy Loading?

Lazy loading is how React implements code splitting.

It means React loads a component only when itâ€™s actually needed, instead of at the beginning.

ğŸª„ Example (Without Lazy Loading)
import Profile from './Profile'; // always loaded

function App() {
return <Profile />;
}

Here, the Profile component loads immediately, even if the user never visits it. âŒ

âœ… Example (With Lazy Loading)
import React, { Suspense, lazy } from 'react';

const Profile = lazy(() => import('./Profile'));

function App() {
return (
<Suspense fallback={<p>Loading...</p>}>
<Profile />
</Suspense>
);
}

ğŸ§  What happens:

React doesnâ€™t load Profile until itâ€™s actually rendered.

While loading, React shows the fallback (Loading...).

Once itâ€™s downloaded, React displays the component.

âš¡ Why Itâ€™s Useful

âœ… Benefits of Code Splitting + Lazy Loading:

Faster initial page load ğŸš€

Less data downloaded upfront

Improved user experience

Scales better for large apps

ğŸ§¾ In short (Interview Answer):

Code splitting means breaking your appâ€™s code into smaller bundles that load only when needed.
Lazy loading is the technique React uses to load components on demand â€” improving performance and reducing initial load time.

---

29. What is the difference between React.PureComponent and React.Component?

ğŸ§© React.Component
Itâ€™s the normal React class component.
It re-renders every time its parent re-renders â€” even if the props or state didnâ€™t actually change.

You have to manually control when to re-render (e.g., by using shouldComponentUpdate).

Example:

class MyComponent extends React.Component {
render() {
console.log("Rendered!");
return <div>{this.props.name}</div>;
}
}

âœ… It will render every time, even if name stays the same.

âš¡ React.PureComponent

It is just like React.Component, but smarter.

It automatically checks if the props or state changed (shallow comparison).

If nothing changed, it skips re-rendering â€” which makes it faster.

Example:

class MyPureComponent extends React.PureComponent {
render() {
console.log("Rendered!");
return <div>{this.props.name}</div>;
}
}

âœ… It will not re-render if name is the same as before.

---

30. ğŸ§© What is the key prop in react lists?

When you render a list in React (using .map()), each element needs a unique key prop.
Example:

{items.map(item => (

  <li key={item.id}>{item.name}</li>
))}

âš™ï¸ Why is key important?

React uses the Virtual DOM to compare the old and new UI when something changes.
When rendering lists, React needs a way to identify each item â€” thatâ€™s what key does.

It helps React know which items changed, added, or removed.

ğŸ“Š Example (Without keys):

<ul>
  <li>A</li>
  <li>B</li>
  <li>C</li>
</ul>

If you insert a new item at the top (X), React doesnâ€™t know which <li> changed â€”
it may re-render all items unnecessarily.

âœ… Example (With keys):

<ul>
  <li key="A">A</li>
  <li key="B">B</li>
  <li key="C">C</li>
</ul>

Now React knows:

A new key â€œXâ€ was added at the top

Keys â€œAâ€, â€œBâ€, â€œCâ€ still exist
ğŸ‘‰ It only re-renders the new item, not the whole list.

---

31. How do you conditionally render list items in React?

It means show some list items only if a condition is true â€”
for example, showing only active users, or hiding items that are empty.

âš™ï¸ Common ways to do it in React lists:

1. Using .filter() before .map()

This is the cleanest way.

const users = [
{ name: "Prem", active: true },
{ name: "Sai", active: false },
{ name: "Noolu", active: true },
];

// Show only active users

<ul>
  {users
    .filter(user => user.active)
    .map(user => (
      <li key={user.name}>{user.name}</li>
    ))}
</ul>

âœ… Only â€œPremâ€ and â€œNooluâ€ will appear.

2. Using a condition inside .map()

You can check the condition inside map() and return something only if itâ€™s true.

<ul>
  {users.map(user =>
    user.active ? <li key={user.name}>{user.name}</li> : null
  )}
</ul>

âœ… If the condition is false, React just skips that item (returns null).

3. Using short-circuit (&&)

If you only want to render an item when something is true:

<ul>
  {users.map(user => (
    user.active && <li key={user.name}>{user.name}</li>
  ))}
</ul>

âœ… && means â€œif the left side is true, show the right sideâ€.

---

32. How do you update or remove an item from a list in React state?
    ğŸ§  React rule:

In React, you never change (mutate) state directly.
Instead, you create a new array and then update the state with it.

ğŸ§© Example list:
const [items, setItems] = useState(["Apple", "Banana", "Cherry"]);

ğŸ 1. Updating an item

Say you want to change â€œBananaâ€ to â€œMangoâ€.

You can use .map() to create a new array where only one item is changed.

const updateItem = (oldItem, newItem) => {
setItems(items.map(item => (item === oldItem ? newItem : item)));
};

When you call:

updateItem("Banana", "Mango");

Now the list becomes:

["Apple", "Mango", "Cherry"]

âœ… React re-renders the UI automatically.

ğŸ’ 2. Removing an item

You can use .filter() to remove something.

const removeItem = (itemToRemove) => {
setItems(items.filter(item => item !== itemToRemove));
};

When you call:

removeItem("Apple");

Now the list becomes:

["Banana", "Cherry"]

ğŸ§© 3. Adding an item

Just for completeness ğŸ˜Š

const addItem = (newItem) => {
setItems([...items, newItem]);
};

âš ï¸ Remember:

Donâ€™t do this: items.push("Mango") â€” âŒ (mutates the array)
Do this: setItems([...items, "Mango"]) â€” âœ… (creates a new one)

---

33. How are forms handled in React compared to plain HTML?

In plain HTML, forms handle data automatically â€” when you submit, the browser collects all the input values and sends them to a server (usually reloading the page).
Example (HTML):

<form action="/submit" method="POST">
  <input type="text" name="username" />
  <button type="submit">Submit</button>
</form>

â¡ï¸ The browser handles everything â€” you donâ€™t control the data directly in JavaScript.

In React, forms are handled manually using state.
You control the input values using state variables and event handlers, so React always knows whatâ€™s in the form.
Example (React):
import { useState } from "react";

function MyForm() {
const [username, setUsername] = useState("");

const handleSubmit = (e) => {
e.preventDefault(); // stops page reload
console.log(username); // handle data manually
};

return (

<form onSubmit={handleSubmit}>
<input
type="text"
value={username}
onChange={(e) => setUsername(e.target.value)}
/>
<button type="submit">Submit</button>
</form>
);
}

â¡ï¸ In React:
You control inputs using state (value + onChange).

You prevent the default form behavior (page reload).

You decide what happens when the form is submitted (e.g., send data with fetch or axios).

ğŸŸ¢ In short:
HTML forms: Browser handles the data.
React forms: You handle the data using state and events.
