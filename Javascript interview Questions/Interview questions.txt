1. What Are Tagged Templates?

A tagged template allows you to call a function on a template literal before it produces a final string.

The function (called the tag) receives:

The literal string parts
The values inside ${ }

It can then modify, filter, or transform the template however it wants.

üîµ How It Works (Simple Example)
function tag(strings, ...values) {
  console.log(strings);
  console.log(values);
}

let name = "Prem";
let age = 25;

tag`My name is ${name} and I am ${age} years old.`;

Output:
strings = ["My name is ", " and I am ", " years old."]
values  = ["Prem", 25]


‚úîÔ∏è JavaScript splits the template into

Strings (fixed parts)
Values (variables)

-----------------------------------

2. What are Symbol s used for in JavaScript?

Symbols are a primitive data type in JavaScript that create unique and hidden identifiers.
They are mainly used to avoid naming conflicts and to create private-like properties in objects.

üü¶ What are Symbols used for?
1. To Create Unique Object Keys (No Name Collisions)

Symbols ensure that two keys never overwrite each other.

Example:
let id = Symbol("id");

let user = {
  name: "Prem",
  age: 25,
  [id]: 123
};

console.log(user[id]); // 123

Even if another developer uses "id" as a key, it won‚Äôt conflict with your Symbol key.

2. To Add Hidden / Private-like Properties

Example:

let secret = Symbol("secret");

let obj = {
  name: "Prem",
  [secret]: "hidden value"
};

console.log(Object.keys(obj));   // ["name"]
console.log(obj[secret]);        // "hidden value"


‚úîÔ∏è Symbol properties remain hidden from normal inspection.

‚úîÔ∏è Why?

Because:

id (string "id") is a normal key

id (Symbol("id")) is a unique key

Even if the Symbol has the same description "id", it is not equal to the string "id".

üîç Let‚Äôs see what the object actually looks like:
let id = Symbol("id");

let user = {
  name: "Prem",
  age: 25,
  [id]: 123
};

user.id = "public id";  // string key "id"

console.log(user);

Resulting object has two different keys:
{
  name: "Prem",
  age: 25,
  id: "public id",     // normal string key
  [Symbol(id)]: 123    // unique Symbol key
}


Both exist separately!
They do NOT overwrite each other.

----------------------------------

3. What are proxies in JavaScript used for?

JavaScript Proxies are a powerful feature that allow you to intercept and customize the behavior of objects.

Think of a Proxy as a middleman between your code and an object.

‚úÖ What is a Proxy?

A Proxy wraps an object and lets you control operations like:

getting a property (obj.property)

setting a property (obj.property = value)

deleting a property

checking if a property exists

calling a function

And much more.

üü¶ Basic Syntax
let proxy = new Proxy(targetObject, handler);


targetObject ‚Üí the original object you want to monitor

handler ‚Üí an object with functions called traps that intercept operations

üü¢ Example: Intercepting Property Access (get)
let user = { name: "Prem", age: 25 };

let proxy = new Proxy(user, {
  get(target, property) {
    console.log(`Reading property: ${property}`);
    return target[property];
  }
});

console.log(proxy.name);

Output:
Reading property: name
Prem


‚úîÔ∏è The Proxy intercepts the read operation.

üü¢ Example: Validating Data When Setting Properties (set)
let user = {
  age: 25
};

let proxy = new Proxy(user, {
  set(target, prop, value) {
    if (prop === "age" && value < 0) {
      throw new Error("Age cannot be negative");
    }
    target[prop] = value;
    return true;
  }
});

proxy.age = 30;   // OK
proxy.age = -5;   // ‚ùå Error: Age cannot be negative

‚úîÔ∏è The Proxy controls how properties are modified.

üü¢ Example: Logging Every Operation
let data = {};

let proxy = new Proxy(data, {
  get(target, prop) {
    console.log(`Get: ${prop}`);
    return target[prop];
  },
  set(target, prop, value) {
    console.log(`Set: ${prop} = ${value}`);
    target[prop] = value;
    return true;
  }
});

proxy.a = 10;  // Set intercepted
console.log(proxy.a);  // Get intercepted

------------------------------------------------

4. What are rest parameters and how are they used?
Rest parameters in JavaScript allow a function to accept an indefinite number of
arguments as an array. They are denoted by three dots ( ... ) followed by the name of
the array. This feature is useful for functions that need to handle multiple arguments
without knowing the exact number in advance.

function sum(...numbers) {
return numbers.reduce((acc, curr) => acc + curr, 0);
}
console.log(sum(1, 2, 3, 4)); // Output: 10

-----------------------------------------

5. What are Arrow Functions?

Arrow functions were introduced in ES6 as a shorter and cleaner syntax for writing functions.
They work great for callbacks and functional programming‚Äîbut they have important limitations.

Limitations of Arrow Functions (Interview Explanation)
1Ô∏è‚É£ Cannot be accessed before initialization
Arrow functions are not hoisted like normal function declarations.

sayHello(); // ‚ùå ReferenceError
const sayHello = () => {
  console.log("Hello");
};

üëâ Why?
Arrow functions are stored in variables (let / const), and variables are not usable before initialization.

2Ô∏è‚É£ No arguments object

Arrow functions do not have their own arguments object.

function normalFunc() {
  console.log(arguments);
}
normalFunc(1, 2); // ‚úÖ [1, 2]

const arrowFunc = () => {
  console.log(arguments);
};
arrowFunc(1, 2); // ‚ùå ReferenceError


üëâ Alternative: Use rest parameters

const arrowFunc = (...args) => {
  console.log(args);
};

3Ô∏è‚É£ No own this (Very important ‚≠ê)

Arrow functions do not have their own this.
They inherit this from the surrounding (lexical) scope.

const user = {
  name: "Prem",
  greet: () => {
    console.log(this.name);
  }
};

user.greet(); // ‚ùå undefined

üëâ Because this here refers to the outer scope, not user.

‚úÖ Correct way:

const user = {
  name: "Prem",
  greet() {
    console.log(this.name);
  }
};

4Ô∏è‚É£ Cannot be used as constructors

Arrow functions cannot be used with new.

const Person = () => {
  this.name = "Prem";
};

const p = new Person(); // ‚ùå TypeError

üëâ Reason:
Arrow functions do not have:

this
prototype
constructor

5Ô∏è‚É£ Cannot be used as generator functions

Arrow functions cannot use yield.

const gen = () => {
  yield 1; // ‚ùå SyntaxError
};

üëâ Generator functions must be declared using function.

üß™ Example 1: Normal function vs Arrow function
const user = {
  name: "Prem",

  normalGreet: function () {
    console.log(this.name);
  },

  arrowGreet: () => {
    console.log(this.name);
  }
};

user.normalGreet(); // Prem
user.arrowGreet();  // undefined

Why?
normalGreet() ‚Üí this refers to user
arrowGreet() ‚Üí this comes from outer scope (global), not user

üß™ Example 2: Arrow function inside a normal method (VERY IMPORTANT)
const user = {
  name: "Prem",

  greet: function () {
    const arrow = () => {
      console.log(this.name);
    };
    arrow();
  }
};

user.greet(); // Prem

What‚Äôs happening?
greet() is a normal function
this inside greet() = user
Arrow function inherits this from greet()
So this.name ‚Üí "Prem"

‚úÖ This is the correct use case for arrow functions.

-----------------------------------

6. forEach and map

forEach() is used to execute a function on each element without returning anything, whereas map() is used to transform array elements and returns a new array.

Key Interview Difference (üî• important)
const result = nums.forEach(n => n * 2);
console.log(result); // undefined

const result = nums.map(n => n * 2);
console.log(result); // [2, 4, 6]
----------------------------------------------------

7. Difference between for...in and for...of in JavaScript (Interview-ready)

Both for...in and for...of are looping constructs, but they are used for different purposes.

üîπ for...in

Iterates over keys / property names
Mostly used for objects
Returns indexes when used with arrays

Example (Object)
const user = { name: "Prem", age: 24 };

for (let key in user) {
  console.log(key, user[key]);
}

Output

name Prem
age 24

Example (Array ‚Äì not recommended)
const arr = [10, 20, 30];

for (let i in arr) {
  console.log(i, arr[i]);
}


Output:

0 10
1 20
2 30

üîπ for...of

Iterates over values
Used for iterables (Array, String, Map, Set)
Cleaner and safer for arrays
Does not work directly on objects

Example (Array)
const arr = [10, 20, 30];

for (let value of arr) {
  console.log(value);
}

Output

10
20
30

Example (String)
for (let char of "JS") {
  console.log(char);
}

Output:

J
S
-----------------------------------------------

8. 19. Difference between Pure and Impure Functions
üîπ Pure Functions

A pure function is a function that:

‚úÖ Always returns the same output for the same input
‚úÖ Has no side effects
‚úÖ Does not modify or depend on external (non-local) state
‚úÖ Makes code predictable, testable, and reusable

Example (Pure Function)
function greeting(name) {
  return `Hello ${name}`;
}

console.log(greeting("Saikrishna Nangunuri"));


Why this is pure:

Output depends only on name
No external variable is used
Same input ‚Üí same output every time

üîπ Impure Functions

An impure function is a function that:
‚ùå May return different output for the same input
‚ùå Has side effects
‚ùå Depends on or modifies external (non-local) state
‚ùå Harder to test and debug

Example (Impure Function)
let message = "good morning";

function greeting1(name) {
  return `Hello ${name}, ${message}`;
}

console.log(greeting1("Saikrishna Nangunuri"));

Why this is impure:

Output depends on external variable message
If message changes, output changes without changing input

message = "good evening";
console.log(greeting1("Saikrishna Nangunuri"));

‚û° Different output for the same input

-------------------------------------

9. Check the below link for polyfills for forEach, map, filter and reduce functions 
https://dev.to/umerjaved178/polyfills-for-foreach-map-filter-reduce-in-javascript-1h13

---------------------------------------

10. What is TypeScript vs JavaScript (short intro)

JavaScript (JS) is a scripting language that runs directly in the browser or Node.js.
TypeScript (TS) is a superset of JavaScript, meaning:
Any valid JavaScript code is also valid TypeScript code.
TypeScript adds types and extra features on top of JavaScript.

1Ô∏è‚É£ TypeScript is a superset of JavaScript

Meaning:

TypeScript includes all JavaScript features
Plus additional features like:

Static typing
Interfaces
Enums
Generics
Access modifiers

// JavaScript
let age = 25;

// TypeScript
let age: number = 25;

2Ô∏è‚É£ Object-Oriented Programming (OOP) support

TypeScript:

Strong OOP features:

class
interface
abstract class
private, protected, public

JavaScript:

Supports OOP but in a looser, prototype-based way
No interfaces or access modifiers

üëâ TS makes OOP clearer and safer.

3Ô∏è‚É£ Large-scale vs Small-scale applications

TypeScript:

Best for large applications
Helps multiple developers work safely
Easy refactoring and maintenance

JavaScript:

Better for small scripts or simple apps
Less structure ‚Üí harder to manage at scale

4Ô∏è‚É£ Compile-time error checking vs Runtime errors

TypeScript:

Errors are caught during development (compile time)

let count: number = "ten"; // ‚ùå Error before running

JavaScript:

Error happens at runtime

let count = "ten";
count * 2; // ‚ùå Runtime error


üëâ TS reduces production bugs.

5Ô∏è‚É£ Interfaces support

TypeScript:

interface User {
  name: string;
  age: number;
}

let u: User = { name: "Prem", age: 24 };

JavaScript:

‚ùå No interfaces
You rely on documentation or comments

6Ô∏è‚É£ Optional parameters in functions

TypeScript:

function greet(name: string, msg?: string) {
  console.log(name, msg);
}

JavaScript:

Parameters are optional by nature
But no compile-time checking

function greet(name, msg) {
  console.log(name, msg);
}

üëâ TS makes optional parameters explicit and safer.

7Ô∏è‚É£ Compilation time

TypeScript:

Needs to be compiled to JavaScript
Takes extra time
Needs build tools

JavaScript:

Runs directly
No compilation step