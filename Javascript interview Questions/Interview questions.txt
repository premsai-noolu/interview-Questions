1. What Are Tagged Templates?

A tagged template allows you to call a function on a template literal before it produces a final string.

The function (called the tag) receives:

The literal string parts
The values inside ${ }

It can then modify, filter, or transform the template however it wants.

ğŸ”µ How It Works (Simple Example)
function tag(strings, ...values) {
  console.log(strings);
  console.log(values);
}

let name = "Prem";
let age = 25;

tag`My name is ${name} and I am ${age} years old.`;

Output:
strings = ["My name is ", " and I am ", " years old."]
values  = ["Prem", 25]


âœ”ï¸ JavaScript splits the template into

Strings (fixed parts)
Values (variables)

-----------------------------------

2. What are Symbol s used for in JavaScript?

Symbols are a primitive data type in JavaScript that create unique and hidden identifiers.
They are mainly used to avoid naming conflicts and to create private-like properties in objects.

ğŸŸ¦ What are Symbols used for?
1. To Create Unique Object Keys (No Name Collisions)

Symbols ensure that two keys never overwrite each other.

Example:
let id = Symbol("id");

let user = {
  name: "Prem",
  age: 25,
  [id]: 123
};

console.log(user[id]); // 123

Even if another developer uses "id" as a key, it wonâ€™t conflict with your Symbol key.

2. To Add Hidden / Private-like Properties

Example:

let secret = Symbol("secret");

let obj = {
  name: "Prem",
  [secret]: "hidden value"
};

console.log(Object.keys(obj));   // ["name"]
console.log(obj[secret]);        // "hidden value"


âœ”ï¸ Symbol properties remain hidden from normal inspection.

âœ”ï¸ Why?

Because:

id (string "id") is a normal key

id (Symbol("id")) is a unique key

Even if the Symbol has the same description "id", it is not equal to the string "id".

ğŸ” Letâ€™s see what the object actually looks like:
let id = Symbol("id");

let user = {
  name: "Prem",
  age: 25,
  [id]: 123
};

user.id = "public id";  // string key "id"

console.log(user);

Resulting object has two different keys:
{
  name: "Prem",
  age: 25,
  id: "public id",     // normal string key
  [Symbol(id)]: 123    // unique Symbol key
}


Both exist separately!
They do NOT overwrite each other.

----------------------------------

3. What are proxies in JavaScript used for?

JavaScript Proxies are a powerful feature that allow you to intercept and customize the behavior of objects.

Think of a Proxy as a middleman between your code and an object.

âœ… What is a Proxy?

A Proxy wraps an object and lets you control operations like:

getting a property (obj.property)

setting a property (obj.property = value)

deleting a property

checking if a property exists

calling a function

And much more.

ğŸŸ¦ Basic Syntax
let proxy = new Proxy(targetObject, handler);


targetObject â†’ the original object you want to monitor

handler â†’ an object with functions called traps that intercept operations

ğŸŸ¢ Example: Intercepting Property Access (get)
let user = { name: "Prem", age: 25 };

let proxy = new Proxy(user, {
  get(target, property) {
    console.log(`Reading property: ${property}`);
    return target[property];
  }
});

console.log(proxy.name);

Output:
Reading property: name
Prem


âœ”ï¸ The Proxy intercepts the read operation.

ğŸŸ¢ Example: Validating Data When Setting Properties (set)
let user = {
  age: 25
};

let proxy = new Proxy(user, {
  set(target, prop, value) {
    if (prop === "age" && value < 0) {
      throw new Error("Age cannot be negative");
    }
    target[prop] = value;
    return true;
  }
});

proxy.age = 30;   // OK
proxy.age = -5;   // âŒ Error: Age cannot be negative

âœ”ï¸ The Proxy controls how properties are modified.

ğŸŸ¢ Example: Logging Every Operation
let data = {};

let proxy = new Proxy(data, {
  get(target, prop) {
    console.log(`Get: ${prop}`);
    return target[prop];
  },
  set(target, prop, value) {
    console.log(`Set: ${prop} = ${value}`);
    target[prop] = value;
    return true;
  }
});

proxy.a = 10;  // Set intercepted
console.log(proxy.a);  // Get intercepted

------------------------------------------------

4. What are rest parameters and how are they used?
Rest parameters in JavaScript allow a function to accept an indefinite number of
arguments as an array. They are denoted by three dots ( ... ) followed by the name of
the array. This feature is useful for functions that need to handle multiple arguments
without knowing the exact number in advance.

function sum(...numbers) {
return numbers.reduce((acc, curr) => acc + curr, 0);
}
console.log(sum(1, 2, 3, 4)); // Output: 10

-----------------------------------------

5. What are Arrow Functions?

Arrow functions were introduced in ES6 as a shorter and cleaner syntax for writing functions.
They work great for callbacks and functional programmingâ€”but they have important limitations.

Limitations of Arrow Functions (Interview Explanation)
1ï¸âƒ£ Cannot be accessed before initialization
Arrow functions are not hoisted like normal function declarations.

sayHello(); // âŒ ReferenceError
const sayHello = () => {
  console.log("Hello");
};

ğŸ‘‰ Why?
Arrow functions are stored in variables (let / const), and variables are not usable before initialization.

2ï¸âƒ£ No arguments object

Arrow functions do not have their own arguments object.

function normalFunc() {
  console.log(arguments);
}
normalFunc(1, 2); // âœ… [1, 2]

const arrowFunc = () => {
  console.log(arguments);
};
arrowFunc(1, 2); // âŒ ReferenceError


ğŸ‘‰ Alternative: Use rest parameters

const arrowFunc = (...args) => {
  console.log(args);
};

3ï¸âƒ£ No own this (Very important â­)

Arrow functions do not have their own this.
They inherit this from the surrounding (lexical) scope.

const user = {
  name: "Prem",
  greet: () => {
    console.log(this.name);
  }
};

user.greet(); // âŒ undefined

ğŸ‘‰ Because this here refers to the outer scope, not user.

âœ… Correct way:

const user = {
  name: "Prem",
  greet() {
    console.log(this.name);
  }
};

4ï¸âƒ£ Cannot be used as constructors

Arrow functions cannot be used with new.

const Person = () => {
  this.name = "Prem";
};

const p = new Person(); // âŒ TypeError

ğŸ‘‰ Reason:
Arrow functions do not have:

this
prototype
constructor

5ï¸âƒ£ Cannot be used as generator functions

Arrow functions cannot use yield.

const gen = () => {
  yield 1; // âŒ SyntaxError
};

ğŸ‘‰ Generator functions must be declared using function.

ğŸ§ª Example 1: Normal function vs Arrow function
const user = {
  name: "Prem",

  normalGreet: function () {
    console.log(this.name);
  },

  arrowGreet: () => {
    console.log(this.name);
  }
};

user.normalGreet(); // Prem
user.arrowGreet();  // undefined

Why?
normalGreet() â†’ this refers to user
arrowGreet() â†’ this comes from outer scope (global), not user

ğŸ§ª Example 2: Arrow function inside a normal method (VERY IMPORTANT)
const user = {
  name: "Prem",

  greet: function () {
    const arrow = () => {
      console.log(this.name);
    };
    arrow();
  }
};

user.greet(); // Prem

Whatâ€™s happening?
greet() is a normal function
this inside greet() = user
Arrow function inherits this from greet()
So this.name â†’ "Prem"

âœ… This is the correct use case for arrow functions.

-----------------------------------

6. forEach and map

forEach() is used to execute a function on each element without returning anything, whereas map() is used to transform array elements and returns a new array.

Key Interview Difference (ğŸ”¥ important)
const result = nums.forEach(n => n * 2);
console.log(result); // undefined

const result = nums.map(n => n * 2);
console.log(result); // [2, 4, 6]
----------------------------------------------------

7. Difference between for...in and for...of in JavaScript (Interview-ready)

Both for...in and for...of are looping constructs, but they are used for different purposes.

ğŸ”¹ for...in

Iterates over keys / property names
Mostly used for objects
Returns indexes when used with arrays

Example (Object)
const user = { name: "Prem", age: 24 };

for (let key in user) {
  console.log(key, user[key]);
}

Output

name Prem
age 24

Example (Array â€“ not recommended)
const arr = [10, 20, 30];

for (let i in arr) {
  console.log(i, arr[i]);
}


Output:

0 10
1 20
2 30

ğŸ”¹ for...of

Iterates over values
Used for iterables (Array, String, Map, Set)
Cleaner and safer for arrays
Does not work directly on objects

Example (Array)
const arr = [10, 20, 30];

for (let value of arr) {
  console.log(value);
}

Output

10
20
30

Example (String)
for (let char of "JS") {
  console.log(char);
}

Output:

J
S
-----------------------------------------------

8. 19. Difference between Pure and Impure Functions
ğŸ”¹ Pure Functions

A pure function is a function that:

âœ… Always returns the same output for the same input
âœ… Has no side effects
âœ… Does not modify or depend on external (non-local) state
âœ… Makes code predictable, testable, and reusable

Example (Pure Function)
function greeting(name) {
  return `Hello ${name}`;
}

console.log(greeting("Saikrishna Nangunuri"));


Why this is pure:

Output depends only on name
No external variable is used
Same input â†’ same output every time

ğŸ”¹ Impure Functions

An impure function is a function that:
âŒ May return different output for the same input
âŒ Has side effects
âŒ Depends on or modifies external (non-local) state
âŒ Harder to test and debug

Example (Impure Function)
let message = "good morning";

function greeting1(name) {
  return `Hello ${name}, ${message}`;
}

console.log(greeting1("Saikrishna Nangunuri"));

Why this is impure:

Output depends on external variable message
If message changes, output changes without changing input

message = "good evening";
console.log(greeting1("Saikrishna Nangunuri"));

â¡ Different output for the same input

-------------------------------------

9. Check the below link for polyfills for forEach, map, filter and reduce functions 
https://dev.to/umerjaved178/polyfills-for-foreach-map-filter-reduce-in-javascript-1h13