1. What Are Tagged Templates?

A tagged template allows you to call a function on a template literal before it produces a final string.

The function (called the tag) receives:

The literal string parts
The values inside ${ }

It can then modify, filter, or transform the template however it wants.

üîµ How It Works (Simple Example)
function tag(strings, ...values) {
  console.log(strings);
  console.log(values);
}

let name = "Prem";
let age = 25;

tag`My name is ${name} and I am ${age} years old.`;

Output:
strings = ["My name is ", " and I am ", " years old."]
values  = ["Prem", 25]


‚úîÔ∏è JavaScript splits the template into

Strings (fixed parts)
Values (variables)

-----------------------------------

2. What are Symbol s used for in JavaScript?

Symbols are a primitive data type in JavaScript that create unique and hidden identifiers.
They are mainly used to avoid naming conflicts and to create private-like properties in objects.

üü¶ What are Symbols used for?
1. To Create Unique Object Keys (No Name Collisions)

Symbols ensure that two keys never overwrite each other.

Example:
let id = Symbol("id");

let user = {
  name: "Prem",
  age: 25,
  [id]: 123
};

console.log(user[id]); // 123

Even if another developer uses "id" as a key, it won‚Äôt conflict with your Symbol key.

2. To Add Hidden / Private-like Properties

Example:

let secret = Symbol("secret");

let obj = {
  name: "Prem",
  [secret]: "hidden value"
};

console.log(Object.keys(obj));   // ["name"]
console.log(obj[secret]);        // "hidden value"


‚úîÔ∏è Symbol properties remain hidden from normal inspection.

‚úîÔ∏è Why?

Because:

id (string "id") is a normal key

id (Symbol("id")) is a unique key

Even if the Symbol has the same description "id", it is not equal to the string "id".

üîç Let‚Äôs see what the object actually looks like:
let id = Symbol("id");

let user = {
  name: "Prem",
  age: 25,
  [id]: 123
};

user.id = "public id";  // string key "id"

console.log(user);

Resulting object has two different keys:
{
  name: "Prem",
  age: 25,
  id: "public id",     // normal string key
  [Symbol(id)]: 123    // unique Symbol key
}


Both exist separately!
They do NOT overwrite each other.

----------------------------------

3. What are proxies in JavaScript used for?

JavaScript Proxies are a powerful feature that allow you to intercept and customize the behavior of objects.

Think of a Proxy as a middleman between your code and an object.

‚úÖ What is a Proxy?

A Proxy wraps an object and lets you control operations like:

getting a property (obj.property)

setting a property (obj.property = value)

deleting a property

checking if a property exists

calling a function

And much more.

üü¶ Basic Syntax
let proxy = new Proxy(targetObject, handler);


targetObject ‚Üí the original object you want to monitor

handler ‚Üí an object with functions called traps that intercept operations

üü¢ Example: Intercepting Property Access (get)
let user = { name: "Prem", age: 25 };

let proxy = new Proxy(user, {
  get(target, property) {
    console.log(`Reading property: ${property}`);
    return target[property];
  }
});

console.log(proxy.name);

Output:
Reading property: name
Prem


‚úîÔ∏è The Proxy intercepts the read operation.

üü¢ Example: Validating Data When Setting Properties (set)
let user = {
  age: 25
};

let proxy = new Proxy(user, {
  set(target, prop, value) {
    if (prop === "age" && value < 0) {
      throw new Error("Age cannot be negative");
    }
    target[prop] = value;
    return true;
  }
});

proxy.age = 30;   // OK
proxy.age = -5;   // ‚ùå Error: Age cannot be negative

‚úîÔ∏è The Proxy controls how properties are modified.

üü¢ Example: Logging Every Operation
let data = {};

let proxy = new Proxy(data, {
  get(target, prop) {
    console.log(`Get: ${prop}`);
    return target[prop];
  },
  set(target, prop, value) {
    console.log(`Set: ${prop} = ${value}`);
    target[prop] = value;
    return true;
  }
});

proxy.a = 10;  // Set intercepted
console.log(proxy.a);  // Get intercepted

------------------------------------------------

4. What are rest parameters and how are they used?
Rest parameters in JavaScript allow a function to accept an indefinite number of
arguments as an array. They are denoted by three dots ( ... ) followed by the name of
the array. This feature is useful for functions that need to handle multiple arguments
without knowing the exact number in advance.

function sum(...numbers) {
return numbers.reduce((acc, curr) => acc + curr, 0);
}
console.log(sum(1, 2, 3, 4)); // Output: 10

-----------------------------------------

5. What are Arrow Functions?

Arrow functions were introduced in ES6 as a shorter and cleaner syntax for writing functions.
They work great for callbacks and functional programming‚Äîbut they have important limitations.

Limitations of Arrow Functions (Interview Explanation)
1Ô∏è‚É£ Cannot be accessed before initialization
Arrow functions are not hoisted like normal function declarations.

sayHello(); // ‚ùå ReferenceError
const sayHello = () => {
  console.log("Hello");
};

üëâ Why?
Arrow functions are stored in variables (let / const), and variables are not usable before initialization.

2Ô∏è‚É£ No arguments object

Arrow functions do not have their own arguments object.

function normalFunc() {
  console.log(arguments);
}
normalFunc(1, 2); // ‚úÖ [1, 2]

const arrowFunc = () => {
  console.log(arguments);
};
arrowFunc(1, 2); // ‚ùå ReferenceError


üëâ Alternative: Use rest parameters

const arrowFunc = (...args) => {
  console.log(args);
};

3Ô∏è‚É£ No own this (Very important ‚≠ê)

Arrow functions do not have their own this.
They inherit this from the surrounding (lexical) scope.

const user = {
  name: "Prem",
  greet: () => {
    console.log(this.name);
  }
};

user.greet(); // ‚ùå undefined

üëâ Because this here refers to the outer scope, not user.

‚úÖ Correct way:

const user = {
  name: "Prem",
  greet() {
    console.log(this.name);
  }
};

4Ô∏è‚É£ Cannot be used as constructors

Arrow functions cannot be used with new.

const Person = () => {
  this.name = "Prem";
};

const p = new Person(); // ‚ùå TypeError

üëâ Reason:
Arrow functions do not have:

this
prototype
constructor

5Ô∏è‚É£ Cannot be used as generator functions

Arrow functions cannot use yield.

const gen = () => {
  yield 1; // ‚ùå SyntaxError
};

üëâ Generator functions must be declared using function.

üß™ Example 1: Normal function vs Arrow function
const user = {
  name: "Prem",

  normalGreet: function () {
    console.log(this.name);
  },

  arrowGreet: () => {
    console.log(this.name);
  }
};

user.normalGreet(); // Prem
user.arrowGreet();  // undefined

Why?
normalGreet() ‚Üí this refers to user
arrowGreet() ‚Üí this comes from outer scope (global), not user

üß™ Example 2: Arrow function inside a normal method (VERY IMPORTANT)
const user = {
  name: "Prem",

  greet: function () {
    const arrow = () => {
      console.log(this.name);
    };
    arrow();
  }
};

user.greet(); // Prem

What‚Äôs happening?
greet() is a normal function
this inside greet() = user
Arrow function inherits this from greet()
So this.name ‚Üí "Prem"

‚úÖ This is the correct use case for arrow functions.

-----------------------------------

6. forEach and map

forEach() is used to execute a function on each element without returning anything, whereas map() is used to transform array elements and returns a new array.

Key Interview Difference (üî• important)
const result = nums.forEach(n => n * 2);
console.log(result); // undefined

const result = nums.map(n => n * 2);
console.log(result); // [2, 4, 6]
