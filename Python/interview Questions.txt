1. Is Python a compiled language or an interpreted language?

Python is an interpreted language, not a compiled one â€” but with a small twist.

Hereâ€™s the simple explanation ğŸ‘‡

When you run a Python program, Python first compiles your code into bytecode (a lower-level, platform-independent code).

Then, the Python interpreter (like CPython) reads and executes that bytecode line by line.

So you can think of it like this:

ğŸ§  Python is compiled first (to bytecode) and then interpreted (executed line by line).

âœ… Example:
When you run

python my_program.py

Python converts my_program.py â†’ my_program.pyc (bytecode).

Then the interpreter runs that bytecode.

In short:

Python is interpreted because the code is executed by an interpreter, not directly by the machine.

--------------

2. What is a dynamically typed language?
In a dynamically typed language, the data type of a variable is determined at runtime, not at compile time.
No need to declare data types manually; Python automatically detects it based on the assigned value.
Examples of dynamically typed languages: Python, JavaScript.
Examples of statically typed languages: C, C++, Java.
Dynamically typed languages are easier and faster to code.
Statically typed languages are usually faster to execute due to type checking at compile time.

----------------

3. What are Built-in data types in Python? 

In Python, built-in data types are the basic types of values that Python already knows how to work with â€” you donâ€™t need to define them yourself.

Hereâ€™s a simple breakdown ğŸ‘‡

ğŸ§± 1. Numeric Types

Used for numbers.

int â†’ Whole numbers (e.g., 5, -3)

float â†’ Decimal numbers (e.g., 3.14, -2.5)

complex â†’ Numbers with real and imaginary parts (e.g., 2 + 3j)

ğŸ§µ 2. Sequence Types

Used for storing ordered collections.

str â†’ String (text), e.g., "Hello"

list â†’ Ordered, changeable collection, e.g., [1, 2, 3]

tuple â†’ Ordered, unchangeable collection, e.g., (1, 2, 3)

ğŸ“¦ 3. Set Types

Used for unique, unordered collections.

set â†’ {1, 2, 3}

frozenset â†’ Like a set, but cannot be changed

ğŸ“– 4. Mapping Type

dict â†’ Key-value pairs, e.g., {"name": "Prem", "age": 25}

ğŸ§© 5. Boolean Type

bool â†’ Only True or False

âš™ï¸ 6. None Type

NoneType â†’ Represents the absence of a value, e.g., None

----------------

4. What is a break, continue and pass in Python?

1. break

ğŸ‘‰ Stops the loop completely and jumps out of it.

Example:

for i in range(5):
    if i == 3:
        break
    print(i)


ğŸ§© Output:

0
1
2


â¡ï¸ When i becomes 3, the break stops the loop.

ğŸŸ¨ 2. continue

ğŸ‘‰ Skips the current iteration and goes to the next one.

Example:

for i in range(5):
    if i == 2:
        continue
    print(i)


ğŸ§© Output:

0
1
3
4


â¡ï¸ When i is 2, it skips print(i) and moves to the next loop.

ğŸŸ© 3. pass

ğŸ‘‰ Does nothing â€” itâ€™s just a placeholder when you need a statement but donâ€™t want any action yet.

Example:

for i in range(5):
    if i == 2:
        pass  # do nothing
    print(i)


ğŸ§© Output:

0
1
2
3
4


â¡ï¸ pass is ignored by Python â€” useful when writing code youâ€™ll fill in later.

--------------------------

5. What is the difference between a Set and Dictionary?

Set: A collection of unique values	
dict: A collection of key-value pairs
Syntax	{1, 2, 3}	{"name": "Prem", "age": 25}
ğŸ§  2. Structure

Set: Only stores values, and all must be unique.

my_set = {1, 2, 3, 3}
print(my_set)   # {1, 2, 3}  â†’ duplicates removed


Dictionary: Stores key : value pairs.

my_dict = {"name": "Prem", "age": 25}
print(my_dict["name"])  # Output: Prem

âš™ï¸ 3. Accessing Elements

Set: You canâ€™t access items using an index or key (only loop through).

for x in my_set:
    print(x)


Dictionary: You can access values using keys.

print(my_dict["age"])  # 25

ğŸ§® 4. Mutability

Both are mutable, meaning you can add or remove elements.

Set: my_set.add(4)

Dict: my_dict["city"] = "Hyderabad"

ğŸš« 5. Duplicates

Set: No duplicate values allowed.

Dictionary: Keys must be unique, but values can repeat.

-----------

6. What is a lambda function?

A lambda function in Python is a small, anonymous function â€” meaning it doesnâ€™t have a name.
This function can have any number of parameters but, can have just one statement.

square = lambda x: x * x
print(square(5))   #

âœ… Example with filter():

numbers = [1, 2, 3, 4, 5]
even = list(filter(lambda x: x % 2 == 0, numbers))
print(even)   

----------

7. What is a Variable Scope in Python?

Variable Scope in Python means where a variable can be accessed or used in your code.

In simple words â€” scope decides the â€œvisibilityâ€ of a variable.

There are 4 types of variable scopes in Python, known as the LEGB rule:

L â€“ Local:
Variables created inside a function.
ğŸ‘‰ You can use them only inside that function.

def my_func():
    x = 10   # local variable
    print(x)

my_func()
# print(x)  # âŒ Error: x not defined outside the function


E â€“ Enclosing:
Variables in an outer function, used by an inner function.

def outer():
    y = 20
    def inner():
        print(y)  # can access outer variable
    inner()
outer()


G â€“ Global:
Variables created outside any function â€” available everywhere in the file.

z = 30
def show():
    print(z)
show()
print(z)


B â€“ Built-in:
Names that are already defined in Python (like len, print, etc.).

-------------

8. What is docstring in Python?

A docstring in Python is a special type of comment used to explain what a function, class, or module does.

It helps others (and you) understand your code easily.

âœ… How to write a docstring:
Use triple quotes (""" ... """) just below the function or class definition.

Example:

def add(a, b):
    """This function adds two numbers and returns the result."""
    return a + b

print(add(3, 5))


âœ… How to access a docstring:
You can see it using the __doc__ attribute:

print(add.__doc__)
# Output: This function adds two numbers and returns the result.


ğŸ‘‰ In simple words:

A docstring is a short explanation written inside triple quotes that describes what a function or class does. Itâ€™s mainly used for documentation.

---------------

9. What is the difference between Python Arrays and Lists?

lists: Built-In
Array: We have import from array.

my_list = [1, "apple", 3.5]
print(my_list)

# Array
from array import array
my_array = array('i', [1, 2, 3])
print(my_array)
ğŸ‘‰ In simple words:

A list can hold anything (numbers, strings, etc.) and is used most of the time.
An array can hold only one data type and is used when you need to handle lots of numbers efficiently.

-----------------

10. What are Modules and Packages in Python?

Module

A module in Python is just a file that contains Python code â€” like functions, classes, or variables â€” that you can reuse in other programs.

âœ… Example:
Suppose you have a file math_utils.py:

# math_utils.py
def add(a, b):
    return a + b


You can use this code in another file:

import math_utils

print(math_utils.add(3, 5))  # Output: 8


ğŸ‘‰ In short:

A module is a single Python file (.py) that you can import and use in other programs.

ğŸ“¦ Package

A package is a collection of modules grouped together in a folder.
It helps organize your code better when you have many modules.

âœ… Example structure:

my_package/
â”‚
â”œâ”€â”€ __init__.py
â”œâ”€â”€ math_utils.py
â””â”€â”€ string_utils.py



You can use it like this:

from my_package import math_utils
print(math_utils.add(2, 3))


ğŸ‘‰ In short:

A package is a folder that contains multiple modules (and an __init__.py file).

-------------

11. What is the difference between xrange and range functions?

âœ… Example (Python 2 style)

# range()
for i in range(5):
    print(i)
# Creates a list [0, 1, 2, 3, 4]

# xrange()
for i in xrange(5):
    print(i)
# Creates numbers one by one (generator)


âœ… In Python 3:

for i in range(5):
    print(i)
# Works like xrange â€” generates numbers one at a time


ğŸ‘‰ In simple words:

In Python 2, xrange() was more memory-efficient than range().
In Python 3, range() was improved to work like xrange(), so xrange() no longer exists.

------------

12. What is Dictionary Comprehension?

Example 1 â€“ Simple dictionary comprehension
squares = {x: x**2 for x in range(1, 6)}
print(squares)

Output:

{1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

Here, each number x becomes a key, and its square x**2 becomes the value.

âœ… Example 2 â€“ Filtering items
even_squares = {x: x**2 for x in range(1, 6) if x % 2 == 0}
print(even_squares)

Output:

{2: 4, 4: 16}

ğŸ‘‰ In simple words:

Dictionary comprehension lets you create a new dictionary in one short line instead of writing long for loops.

-------------

13. What is the difference between a shallow copy and a deep copy?

. Shallow Copy

A shallow copy creates a new object, but it does not copy the inner objects â€” it just references them.

âœ… Example:

import copy

list1 = [[1, 2], [3, 4]]
list2 = copy.copy(list1)

list2[0][0] = 99

print(list1)  # [[99, 2], [3, 4]]
print(list2)  # [[99, 2], [3, 4]]

Both lists changed because they share the same inner lists.

ğŸ‘‰ In short:

Shallow copy copies only the outer object, not the nested objects inside it.

ğŸ§  2. Deep Copy

A deep copy creates a completely new copy of the object and all its nested elements.

âœ… Example:

import copy

list1 = [[1, 2], [3, 4]]
list2 = copy.deepcopy(list1)

list2[0][0] = 99

print(list1)  # [[1, 2], [3, 4]]
print(list2)  # [[99, 2], [3, 4]]

Here, changes in list2 do not affect list1.

ğŸ‘‰ In short:

Deep copy copies everything â€” the object and all nested objects â€” so they are completely independent.

-----------------

14. What are Decorators?

Letâ€™s say you have a function:

def say_hello():
    print("Hello, Prem!")

When you call it:

say_hello()

Output:
Hello, Prem!

Simple â€” nothing fancy.

ğŸ§  Step 2: Now imagine you want to add something extra

For example â€” you want to print a line before and after saying hello.

You can do this by writing a new function that wraps the old one:

def add_message(func):
    def wrapper():
        print("Before the function runs...")
        func()   # calling the original function
        print("After the function runs...")
    return wrapper


Here:

add_message is a decorator function.

It takes another function (func) as input.

It adds extra behavior before and after that function runs.

ğŸ§© Step 3: Use the decorator

Instead of doing this manually:

say_hello = add_message(say_hello)
say_hello()


You can just use the @ symbol:

@add_message
def say_hello():
    print("Hello, Prem!")


Now when you call:

say_hello()


Output:

Before the function runs...
Hello, Prem!
After the function runs...

ğŸ§  Step 4: Whatâ€™s happening behind the scenes

When you write:

@add_message
def say_hello():
    print("Hello!")


Python automatically does this:

say_hello = add_message(say_hello)


So the decorator â€œwrapsâ€ your function with new behavior â€” like a gift wrapper around a present ğŸ.

âœ… Step 5: Where decorators are used in real projects

Logging â€“ track when a function runs.

Authentication â€“ check if a user is logged in before running a function.

Timing â€“ measure how long a function takes to run.

Flask/Django â€“ for routes like @app.route('/').

ğŸ’¡ Simple Interview Answer:

â€œA decorator in Python is a special function that allows us to add extra behavior to another function without changing its code.
It works by taking a function as input, adding something around it, and returning a new function.
We use the @decorator_name syntax before the function definition.â€

-------------

15. How do you debug a Python program?

ğŸ§  What does debugging mean?

Debugging means finding and fixing errors (bugs) in your Python code.
Python gives you several tools and methods to do this easily.

âœ… 1. Using print statements (most common way)

You can use print() to check what your code is doing at each step.

Example:

def divide(a, b):
    print("a:", a, "b:", b)   # debug info
    return a / b

print(divide(10, 2))


If something goes wrong, print statements help you see variable values and find where the issue is.

ğŸŸ¡ Simple but not ideal for large programs.

âœ… 2. Using the built-in pdb (Python Debugger)

Python has a built-in debugger called pdb which allows you to:

Stop the program at a specific line

Check variable values

Step through the code line by line

Example:

import pdb

def divide(a, b):
    pdb.set_trace()   # pause execution here
    return a / b

divide(10, 0)


Common pdb commands:

n â†’ go to next line

s â†’ step into a function

c â†’ continue execution

q â†’ quit debugger

p variable â†’ print variable value

ğŸ§© Best for serious debugging.

âœ… 3. Using an IDE Debugger (like VS Code, PyCharm, or IDLE)

Modern IDEs have a graphical debugger:

You can set breakpoints (places where the program stops).

You can inspect variables.

You can step through the code line by line.

ğŸ’¡ This is the easiest and most visual way for beginners.

âœ… 4. Using Logging (for bigger projects)

Instead of using print everywhere, use the logging module:

import logging

logging.basicConfig(level=logging.DEBUG)
logging.debug("Starting the division function...")

def divide(a, b):
    logging.info(f"Dividing {a} by {b}")
    return a / b


Logging can record info, warnings, and errors in files â€” helpful for debugging after deployment.

-----------------

16. What are Iterators in Python?

ğŸ§© What is an Iterator?

An iterator in Python is an object that allows you to go through (iterate over) elements one at a time.

It remembers where it left off â€” so you can get the next item until there are no items left.

âœ… Example:
numbers = [1, 2, 3]
it = iter(numbers)   # create an iterator

print(next(it))  # Output: 1
print(next(it))  # Output: 2
print(next(it))  # Output: 3
# print(next(it))  # âŒ Raises StopIteration (no more items)


Here:

iter() â†’ converts the list into an iterator object.

next() â†’ gives the next item from the iterator.

When no items are left, it raises a StopIteration error.

ğŸ§  In simple words:

An iterator is an object that lets you loop through data one element at a time.

âœ… Example with a loop:

You donâ€™t usually use next() directly â€” you use a for loop:

for num in [1, 2, 3]:
    print(num)


Under the hood, Python automatically:

Calls iter() on the list

Repeatedly calls next() on the iterator

Stops when StopIteration is raised

ğŸ’¡ Interview Answer (simple):

â€œAn iterator in Python is an object that returns data one element at a time when we call next() on it.
It is created using the iter() function, and when there are no more elements, it raises a StopIteration exception.
A for loop internally uses iterators to go through items in a sequence.â€

---------------

17. What is a Generator?

A generator in Python is a special type of function that lets you generate values one at a time, instead of returning them all at once.

Itâ€™s used when you have a large amount of data and donâ€™t want to store everything in memory.

âœ… How to create a generator

You create a generator using the yield keyword instead of return.

Example:

def count_up_to(n):
    i = 1
    while i <= n:
        yield i    # pauses here and returns the value
        i += 1


Now, you can use it like this:

numbers = count_up_to(5)

print(next(numbers))  # 1
print(next(numbers))  # 2
print(next(numbers))  # 3


Each time you call next(), the function resumes from where it left off â€” it doesnâ€™t restart.

ğŸ§  In simple words:

A generator is a function that remembers where it left off and gives you the next value when needed â€” it doesnâ€™t store all values in memory.

ğŸ’¡ Interview Answer (simple):

â€œA generator in Python is a function that uses yield instead of return to produce values one by one.
It doesnâ€™t store all the values in memory â€” it generates them on the fly when needed.
Generators are useful for handling large data or streams efficiently.â€

-------------

18. Does Python supports multiple Inheritance?

Yes, Python supports Multiple Inheritance.
âœ… Example:
class Father:
    def driving(self):
        print("Father knows driving.")

class Mother:
    def cooking(self):
        print("Mother knows cooking.")

class Child(Father, Mother):
    def playing(self):
        print("Child loves playing football.")

# Create object of Child
obj = Child()

# Access methods from both parents and the child
obj.driving()   # From Father
obj.cooking()   # From Mother
obj.playing()   # From Child


ğŸ§¾ Output:

Father knows driving.
Mother knows cooking.
Child loves playing football.

ğŸ§  Explanation:

The Child class inherits from both Father and Mother.

It automatically gets access to their methods (driving() and cooking()).

You can also add the childâ€™s own method (playing()).

ğŸ’¡ In simple words:

In multiple inheritance, the child class can use methods from all parent classes, along with its own methods.
If parent methods have different names, they all work independently â€” no conflict.

ğŸ’¡ Interview Answer (simple):

â€œYes, Python supports multiple inheritance.
It means a class can inherit from more than one parent class.
If there are methods with the same name, Python follows the Method Resolution Order (MRO) â€” it checks from left to right.â€

---------------

19. What is Polymorphism in Python?

Polymorphism means â€œmany forms.â€
In Python, it allows the same function or method name to behave differently depending on the object that calls it.

ğŸ‘‰ In simple words:

Polymorphism lets you use the same function name for different types of objects.

âœ… Example 1 â€“ Same method name, different behavior
class Dog:
    def sound(self):
        return "Bark"

class Cat:
    def sound(self):
        return "Meow"

# Using the same method name for different objects
for animal in [Dog(), Cat()]:
    print(animal.sound())


Output:

Bark
Meow


ğŸ”¹ Both classes have a method named sound(),
but each one behaves differently for its object.

âœ… Example 2 â€“ Polymorphism with inheritance
class Bird:
    def intro(self):
        print("There are many types of birds.")
    def flight(self):
        print("Most birds can fly.")

class Penguin(Bird):
    def flight(self):
        print("Penguins cannot fly.")

obj1 = Bird()
obj2 = Penguin()

obj1.intro()
obj1.flight()

obj2.intro()
obj2.flight()


Output:

There are many types of birds.
Most birds can fly.
There are many types of birds.
Penguins cannot fly.


ğŸ”¹ Here, the flight() method is overridden in the child class to behave differently â€”
this is called runtime polymorphism or method overriding.

âœ… Example 3 â€“ Polymorphism with built-in functions
print(len("Hello"))   # String â†’ counts characters
print(len([1, 2, 3])) # List â†’ counts elements


ğŸ”¹ The same function len() behaves differently depending on the data type â€”
thatâ€™s polymorphism too!

ğŸ’¡ Interview Answer (simple):

â€œPolymorphism in Python means having the same function or method name behave differently for different objects.
It allows flexibility in code â€” the same interface can work with different types of data or classes.
For example, the len() function works for both strings and lists, and classes can override parent methods to change behavior.â€

-----------

20. Define encapsulation in Python?

Encapsulation means wrapping data (variables) and methods (functions) together into a single unit (class) and restricting direct access to some parts of the object.

ğŸ‘‰ In simple words:

Encapsulation is like putting data inside a capsule so that it canâ€™t be changed directly â€” only through controlled methods.

âœ… Example:
class Car:
    def __init__(self):
        self.__speed = 0   # private variable

    def accelerate(self):
        self.__speed += 10

    def brake(self):
        self.__speed -= 10

    def get_speed(self):
        return self.__speed

car = Car()
car.accelerate()
car.accelerate()
print(car.get_speed())   # Access speed using method

# Direct access will not work
# print(car.__speed)  âŒ This will cause an error


Output:

20

ğŸ§  Explanation:

__speed is a private variable (cannot be accessed directly outside the class).

You can change or read it only through the methods (accelerate, brake, get_speed).

This protects the data from being modified accidentally.

ğŸª„ Encapsulation helps:

Protect data from direct access.

Control how data is changed.

Make code cleaner and safer.

ğŸ’¡ Interview Answer (simple):

â€œEncapsulation in Python means hiding the internal details of a class and only exposing necessary parts.
Itâ€™s done by making variables private (using __) and accessing them through public methods like getters and setters.â€

--------------

21. What is Data Abstraction?

Data Abstraction means showing only the necessary details to the user and hiding the complex internal logic.

ğŸ‘‰ In simple words:

Abstraction is about what an object does, not how it does it.

âœ… Real-life Example:

Think of a TV remote â€”
You can press buttons to change channels or volume,
but you donâ€™t know the complex circuits working inside.
Thatâ€™s abstraction â€” you only see the useful part.

âœ… Example in Python:

In Python, abstraction is usually done using abstract classes and methods (from the abc module).

from abc import ABC, abstractmethod

class Vehicle(ABC):
    @abstractmethod
    def start(self):
        pass  # Abstract method (only declared, not defined)

class Car(Vehicle):
    def start(self):
        print("Car engine started with key.")

class Bike(Vehicle):
    def start(self):
        print("Bike started with self-start button.")

# obj = Vehicle()  âŒ Can't create object of abstract class
car = Car()
bike = Bike()

car.start()
bike.start()


Output:

Car engine started with key.
Bike started with self-start button.

ğŸ§  Explanation:

Vehicle is an abstract class â€” it provides a template for its subclasses.

start() is an abstract method â€” every subclass must define it.

This hides how the start mechanism works and only exposes what it does (the interface).

ğŸ’¡ Interview Answer (simple):

â€œData abstraction in Python means hiding complex implementation details and showing only the essential features.
It can be achieved using abstract classes and abstract methods from the abc module.
This helps in designing clean and reusable code where subclasses define their own specific behavior.â€

-----------------

22. How is memory management done in Python?

What is Memory Management?

Memory management means how Python allocates, tracks, and frees up memory while your program runs â€” so that memory is used efficiently and no data is wasted.

âœ… 1. Python has an Automatic Memory Management System

You donâ€™t need to manually allocate or free memory (like in C or C++).
Pythonâ€™s memory manager and garbage collector handle it automatically.

âœ… 2. Memory Allocation in Python

Python divides memory into two parts:

Stack memory â†’ for local variables inside functions.

Heap memory â†’ for objects like lists, dictionaries, classes, etc.

When you create a variable or an object, Python automatically allocates space for it in the heap.

-----------------------------

23. ğŸ—‚ï¸ File Handling in Python

File handling allows you to create, read, write, and delete files using Python.
Itâ€™s important for saving data permanently (unlike variables which are lost when the program ends).

ğŸ”¹ Basic File Operations
Mode	Description
'r'	Read mode (default). Opens file for reading â€“ file must exist.
'w'	Write mode. Creates a new file or overwrites existing file.
'a'	Append mode. Adds data to the end of the file.
'x'	Create mode. Creates a new file; fails if file already exists.
'r+'	Read and write mode.
't'	Text mode (default).
'b'	Binary mode (for images, etc.).
ğŸ“– 1. Reading a File
# Open file in read mode
file = open("example.txt", "r")

# Read full content
content = file.read()
print(content)

# Close the file
file.close()


Or read line by line:

file = open("example.txt", "r")
for line in file:
    print(line.strip())
file.close()

âœï¸ 2. Writing to a File
# Opens (or creates) file and overwrites content
file = open("example.txt", "w")
file.write("Hello, this is a new line.")
file.close()

â• 3. Appending to a File
file = open("example.txt", "a")
file.write("\nThis line is added later.")
file.close()

âœ… 4. Using with Statement (Best Practice)

Using with automatically closes the file after use.

with open("example.txt", "r") as file:
    data = file.read()
    print(data)

ğŸ§¾ 5. Reading and Writing Files Together
with open("example.txt", "r+") as file:
    content = file.read()
    file.write("\nNew content added after reading.")

ğŸ§° 6. Deleting a File

Use the os module:

import os

if os.path.exists("example.txt"):
    os.remove("example.txt")
else:
    print("File not found.")

ğŸ§  Summary

open() â†’ to open a file

read(), write(), append() â†’ to work with file data

Always close the file (or use with)

os â†’ to handle file operations like delete or check existence

ğŸ§¾ Example: Copy Contents from One File to Another
ğŸ“ Step 1: Create a file (source.txt)

Letâ€™s say source.txt contains:

Hello, this is the source file.
We are learning file handling in Python.

ğŸ’» Step 2: Python Program
# Open the source file in read mode
with open("source.txt", "r") as src:
    # Read all contents
    content = src.read()

# Open the destination file in write mode
with open("destination.txt", "w") as dest:
    # Write the content to the new file
    dest.write(content)

print("File copied successfully!")

ğŸ§  Explanation:

with open("source.txt", "r") as src: â†’ Opens the source file for reading.
content = src.read() â†’ Reads the entire file content into a variable.
with open("destination.txt", "w") as dest: â†’ Opens or creates a new file for writing.
dest.write(content) â†’ Writes the content into the new file.
with â†’ Automatically closes both files after use.

âœ… Output:

After running the program:
A new file named destination.txt will be created.
It will have the same content as source.txt.

---------------------------------

24. ğŸ§  Understanding Multithreading in Python
ğŸ”¹ What is Multithreading?

Multithreading means running multiple parts (threads) of a program concurrently.

Each thread runs independently but shares the same memory space.

In Python, threads are handled by the threading module.

Threads are useful for:

Downloading multiple files simultaneously

Reading/writing files while doing other work
ğŸ’» Example: Two Classes Inheriting from Thread

Here weâ€™ll define two custom thread classes, both doing different tasks â€” and theyâ€™ll run concurrently.

from threading import *
import time

# First class inheriting Thread
class PrintNumbers(Thread):
    def run(self):
        for i in range(1, 6):
            print(f"Number Thread: {i}")
            time.sleep(1)

# Second class inheriting Thread
class PrintLetters(Thread):
    def run(self):
        for ch in ['A', 'B', 'C', 'D', 'E']:
            print(f"Letter Thread: {ch}")
            time.sleep(1)

# Create objects of both classes
t1 = PrintNumbers()
t2 = PrintLetters()

# Start both threads
t1.start()
t2.start()

# Wait for both to finish
t1.join()
t2.join()

print("Main thread completed.")

ğŸ§¾ Output Example (Interleaved):
Number Thread: 1
Letter Thread: A
Number Thread: 2
Letter Thread: B
Number Thread: 3
Letter Thread: C
Number Thread: 4
Letter Thread: D
Number Thread: 5
Letter Thread: E
Main thread completed.


(Output order may vary â€” because both threads run concurrently.)

ğŸ§© Explanation

class PrintNumbers(Thread)
â†’ Inherits from the Thread class.
â†’ Defines a run() method â€” contains code executed when thread starts.

class PrintLetters(Thread)
â†’ Another child class of Thread.
â†’ Runs independently from the first.

start()
â†’ Starts the thread â€” internally calls the run() method in a new thread.

join()
â†’ Waits until the thread completes before continuing with the main thread.

âš™ï¸ How Multithreading Works Here

The main thread creates two child threads (t1, t2).

Both run simultaneously â€” while one prints numbers, the other prints letters.

The order may vary each time you run the program â€” this is the nature of concurrency.

ğŸ§  Key Takeaways

Threads share the same memory space (unlike processes).

Use Thread class and override run() to define custom thread behavior.

start() launches a thread; join() waits for it to finish.

Ideal for I/O-bound tasks like networking, database, file operations, etc.
Running background tasks (like timers or status updates)

---------------------------------------

25. ğŸ’¡ What is Asynchronous Programming?

Normally, Python executes code line by line â€” one task must finish before the next starts.
Thatâ€™s called synchronous execution.

But in asynchronous programming, Python can start a new task before the previous one finishes, allowing multiple tasks (like network calls or I/O operations) to run concurrently.

This helps improve speed and efficiency, especially for I/O-heavy tasks like:

Fetching data from APIs
Reading/writing files
Database queries

âš™ï¸ Keywords: async and await

These are the core keywords used to write asynchronous code in Python.

ğŸ”¹ async

Used to define a function as asynchronous.

Syntax:

async def my_function():
    ...

An async function doesnâ€™t run immediately â€” it returns a coroutine (an object that can be awaited).

ğŸ”¹ await

Used inside an async function to pause the function until another asynchronous operation completes.

Syntax:

result = await some_async_function()


It tells Python: â€œWait here for this async task to finish before continuing.â€

ğŸ§  Simple Example:

Letâ€™s compare normal (synchronous) vs asynchronous code ğŸ‘‡

ğŸš« Normal Code (Synchronous):
import time

def fetch_data():
    print("Fetching data...")
    time.sleep(2)   # simulates a delay
    print("Data fetched")

def main():
    fetch_data()
    fetch_data()

main()


ğŸ•’ Output:

Fetching data...
Data fetched
Fetching data...
Data fetched


â¡ Total time = 4 seconds (runs one after another)

âœ… Asynchronous Version:
import asyncio

async def fetch_data():
    print("Fetching data...")
    await asyncio.sleep(2)   # non-blocking delay
    print("Data fetched")

async def main():
    # Run both tasks concurrently
    await asyncio.gather(fetch_data(), fetch_data())

asyncio.run(main())



ğŸ•’ Output:

Fetching data...
Fetching data...
Data fetched
Data fetched


â¡ Total time = only 2 seconds (both run together!)

ğŸš€ When to Use async/await:

Use async/await when your program:
Makes network calls (APIs, web scraping)
Does file or database I/O
Waits for delays or background tasks

But avoid async for CPU-heavy tasks (like complex calculations) â€” those need multiprocessing or threading instead.

ğŸ—£ï¸ Interview-Safe Summary:

â€œasync and await are used in Python for asynchronous programming.
async defines a coroutine, and await pauses it until another async task finishes.
This helps run multiple I/O-bound tasks concurrently, improving performance without blocking the main thread.â€

ğŸ§  Example â€” Downloading Data Using async and await
import asyncio

async def download_data(server_name, seconds):
    print(f"Starting download from {server_name}...")
    await asyncio.sleep(seconds)   # Simulates a network delay
    print(f"Finished downloading from {server_name} in {seconds} seconds")

async def main():
    # Run all downloads concurrently
    await asyncio.gather(
        download_data("Server A", 3),
        download_data("Server B", 2),
        download_data("Server C", 1)
    )

# Run the main coroutine
asyncio.run(main())

ğŸ–¥ï¸ Output:
Starting download from Server A...
Starting download from Server B...
Starting download from Server C...
Finished downloading from Server C in 1 seconds
Finished downloading from Server B in 2 seconds
Finished downloading from Server A in 3 seconds

âš™ï¸ How it Works:

All three downloads start at the same time.
Python doesnâ€™t block; it waits (await) only when needed.
Total time â‰ˆ 3 seconds (not 6), since tasks run concurrently.

-------------------------
26. 
ğŸ”¹ Basic Level
1. How do you create an array/list in Python?
arr = [10, 20, 30]

2. How do you access an element from a list?
arr[1]   # Output: 20

3. How do you update a value inside a list?
arr[1] = 200

4. How do you append an item to a list?
arr.append(40)

5. How do you remove an item from a list?
arr.remove(20)

6. How to find the length of a list?
len(arr)

ğŸ”¹ Intermediate Level
7. How do you insert an element at a specific position?
arr.insert(2, 99)

8. How do you extend a list with another list?
arr.extend([5, 6, 7])

9. How do you reverse a list?
arr.reverse()
# OR
arr[::-1]

10. How do you sort a list?
arr.sort()
# OR
sorted(arr)

11. How do you remove the last element?
arr.pop()

12. How do you check if an item exists in a list?
if 10 in arr:
    print("Found")

13. How do you count occurrences of an element?
arr.count(10)

ğŸ”¹ Advanced Level
14. How do you loop through a list with index?
for index, value in enumerate(arr):
    print(index, value)

15. How do you filter a list?

Using lambda:

result = list(filter(lambda x: x > 10, arr))

16. How do you map a list (apply function to each element)?
result = list(map(lambda x: x * 2, arr))

17. How do you create a list using list comprehension?
squares = [x*x for x in arr]

18. How do you remove duplicates from a list?
unique = list(set(arr))

19. How do you flatten a 2D list?
flat = [item for sublist in arr for item in sublist]

20. How do you copy a list (without reference)?
new_arr = arr.copy()
# OR
new_arr = arr[:]

ğŸ”¹ Bonus: Array vs List in Python
Is there an actual array in Python?

Yes â€” using the array module:

import array
arr = array.array('i', [10, 20, 30])

---------------------------------------

27. âœ… How to Handle Exceptions in Python
ğŸ”¹ Use tryâ€“except

You put the risky code in try, and if an error occurs, Python jumps to except.

Example
try:
    x = 10 / 0
except ZeroDivisionError:
    print("You cannot divide by zero!")

ğŸ”¹ General Syntax
try:
    # code that may cause an error
except ErrorType:
    # what to do if that error happens

ğŸ”¹ Handling Multiple Exceptions
try:
    num = int("abc")
except ValueError:
    print("Invalid number")
except TypeError:
    print("Wrong type used")

ğŸ”¹ Catching All Exceptions

(Not recommended always, but useful sometimes)

try:
    a = 5 / 0
except Exception as e:
    print("Error:", e)


e shows the actual error message.

ğŸ”¹ Using else

Runs only when no exception occurs.

try:
    x = int("10")
except ValueError:
    print("Error converting")
else:
    print("No error! Value =", x)

ğŸ”¹ Using finally

Runs always â€” even if there is an exception.

Useful for closing files, database connections, etc.

try:
    file = open("example.txt")
    data = file.read()
except FileNotFoundError:
    print("File not found")
finally:
    print("Cleaning up...")
    file.close()

ğŸ”¹ Raise Your Own Exception
x = -1
if x < 0:
    raise ValueError("x cannot be negative")

â­ Full Example (All Parts)
try:
    num = int(input("Enter a number: "))
except ValueError:
    print("Please enter a valid number!")
else:
    print("Square is:", num * num)
finally:
    print("Program completed.")

----------------------

28. âœ… 1. json.loads() â€” Convert JSON STRING â†’ Python Dictionary

loads() = load string

ğŸ“Œ Takes a JSON string and converts it into Python data.

Example:
import json

json_string = '{"name": "Prem", "age": 25, "language": "Python"}'

data = json.loads(json_string)

print(data)
print(type(data))

âœ… Output:
{'name': 'Prem', 'age': 25, 'language': 'Python'}
<class 'dict'>


âœ” The JSON string becomes a Python dictionary.

âœ… 2. json.dumps() â€” Convert Python Dictionary â†’ JSON STRING

dumps() = dump (Python object) to string

ğŸ“Œ Takes Python data and converts it into JSON-formatted string.

Example:
import json

data = {
    "name": "Prem",
    "age": 25,
    "language": "Python"
}

json_output = json.dumps(data)

print(json_output)
print(type(json_output))

âœ… Output:
{"name": "Prem", "age": 25, "language": "Python"}
<class 'str'>


âœ” The Python dictionary becomes a JSON string.

ğŸ“Œ Add Formatting (Pretty JSON)

Use indent= to make readable JSON.

print(json.dumps(data, indent=4))


Output:

{
    "name": "Prem",
    "age": 25,
    "language": "Python"
}